<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Patterns | Ahmad Adillaumam</title>
<meta name=keywords content><meta name=description content="Introduction

It is common for programmers to create software without careful preparation.
This sometimes makes the software difficult to maintain and develop when it has already been made.
Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used.
In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out.

Software Architecture Patterns

Architecture Patterns are a collection of architectural styles in software development.
There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not.
Programmers need to know about this material so that they can determine what pattern to use when creating software.

Purpose of Architecture Patterns

Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain.
The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future.

Architecture Classification

Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute.
Monolithic is a single deployment unit or runs in one application.
Distributed is multiple deployment units, usually consisting of several applications.

Monolithic Architectures

Monolithic Architecture is generally very simple compared to Distributed Architecture.
Monolithic application design is simpler and easier to implement.
Applications that use Monolithic Architecture will be very fast to build and distribute.


Distributed Architecture

Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application.
Usually in Distributed Architecture, each application unit is called a Service.
Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally.

"><meta name=author content="Ahmad Adillaumam"><link rel=canonical href=https://wewnumam.github.io/articles/software-architecture-patterns/><meta name=google-site-verification content="G-2KZ9LNNSKF"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://wewnumam.github.io/favicon.png><link rel=apple-touch-icon href=https://wewnumam.github.io/favicon.png><link rel=mask-icon href=https://wewnumam.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wewnumam.github.io/articles/software-architecture-patterns/><link rel=alternate hreflang=id href=https://wewnumam.github.io/id/articles/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2KZ9LNNSKF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2KZ9LNNSKF")}</script><meta property="og:url" content="https://wewnumam.github.io/articles/software-architecture-patterns/"><meta property="og:site_name" content="Ahmad Adillaumam"><meta property="og:title" content="Software Architecture Patterns"><meta property="og:description" content="Introduction It is common for programmers to create software without careful preparation. This sometimes makes the software difficult to maintain and develop when it has already been made. Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used. In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out. Software Architecture Patterns Architecture Patterns are a collection of architectural styles in software development. There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not. Programmers need to know about this material so that they can determine what pattern to use when creating software. Purpose of Architecture Patterns Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain. The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future. Architecture Classification Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute. Monolithic is a single deployment unit or runs in one application. Distributed is multiple deployment units, usually consisting of several applications. Monolithic Architectures Monolithic Architecture is generally very simple compared to Distributed Architecture. Monolithic application design is simpler and easier to implement. Applications that use Monolithic Architecture will be very fast to build and distribute. Distributed Architecture Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application. Usually in Distributed Architecture, each application unit is called a Service. Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally. "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2025-04-29T20:27:25+07:00"><meta property="article:modified_time" content="2025-04-29T20:27:25+07:00"><meta property="og:image" content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:title content="Software Architecture Patterns"><meta name=twitter:description content="Introduction

It is common for programmers to create software without careful preparation.
This sometimes makes the software difficult to maintain and develop when it has already been made.
Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used.
In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out.

Software Architecture Patterns

Architecture Patterns are a collection of architectural styles in software development.
There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not.
Programmers need to know about this material so that they can determine what pattern to use when creating software.

Purpose of Architecture Patterns

Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain.
The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future.

Architecture Classification

Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute.
Monolithic is a single deployment unit or runs in one application.
Distributed is multiple deployment units, usually consisting of several applications.

Monolithic Architectures

Monolithic Architecture is generally very simple compared to Distributed Architecture.
Monolithic application design is simpler and easier to implement.
Applications that use Monolithic Architecture will be very fast to build and distribute.


Distributed Architecture

Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application.
Usually in Distributed Architecture, each application unit is called a Service.
Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally.

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://wewnumam.github.io/articles/"},{"@type":"ListItem","position":2,"name":"Software Architecture Patterns","item":"https://wewnumam.github.io/articles/software-architecture-patterns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Software Architecture Patterns","name":"Software Architecture Patterns","description":"Introduction It is common for programmers to create software without careful preparation. This sometimes makes the software difficult to maintain and develop when it has already been made. Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used. In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out. Software Architecture Patterns Architecture Patterns are a collection of architectural styles in software development. There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not. Programmers need to know about this material so that they can determine what pattern to use when creating software. Purpose of Architecture Patterns Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain. The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future. Architecture Classification Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute. Monolithic is a single deployment unit or runs in one application. Distributed is multiple deployment units, usually consisting of several applications. Monolithic Architectures Monolithic Architecture is generally very simple compared to Distributed Architecture. Monolithic application design is simpler and easier to implement. Applications that use Monolithic Architecture will be very fast to build and distribute. Distributed Architecture Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application. Usually in Distributed Architecture, each application unit is called a Service. Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally. ","keywords":[],"articleBody":"Introduction It is common for programmers to create software without careful preparation. This sometimes makes the software difficult to maintain and develop when it has already been made. Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used. In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out. Software Architecture Patterns Architecture Patterns are a collection of architectural styles in software development. There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not. Programmers need to know about this material so that they can determine what pattern to use when creating software. Purpose of Architecture Patterns Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain. The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future. Architecture Classification Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute. Monolithic is a single deployment unit or runs in one application. Distributed is multiple deployment units, usually consisting of several applications. Monolithic Architectures Monolithic Architecture is generally very simple compared to Distributed Architecture. Monolithic application design is simpler and easier to implement. Applications that use Monolithic Architecture will be very fast to build and distribute. Distributed Architecture Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application. Usually in Distributed Architecture, each application unit is called a Service. Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally. Which one to choose? When making applications, sometimes we are confused about whether to use Monolithic or Distributed architecture? If the application we are going to create is simple or still unclear in terms of business requirements, it is highly recommended to use Monolithic, because it is easy to create. But if the application we are going to make is very clear, and also requires good scalability, including good fault tolerance, then we can use Distributed architecture. Architecture Partitioning In addition to the classification of monolithic or distributed, software architecture can also be seen in its partition structure. Software architecture, be it monolithic or distributed, can be partitioned based on technical or domain. Partitioning by structure can be used in monolithic or distributed. Technical Partitioning Technical Partitioning architecture divides the components in the system or application technically. An example of a classic architecture that is often used is Layered (N-Tier) Architecture. In Technical Partitioning, the components in the system are grouped technically, for example : Presentation Layer is the component that handles the user interface. Business Layer, a component that handles business logic and rules. Persistence Layer, a component that handles interaction with the database system. Database Layer, a component for storing data. Domain Partitioning In contrast to Technical Partitioning, in Domain Partitioning, the division of the component structure in the system is grouped based on the Domain / Feature / Department in business. This means that all Technical Partitioning such as Presentation, Business Logic, Persistence, are combined in the system domain. Domain-based system partitioning has been popular since it was introduced in a book titled “Domain Driven Design” by Eric Evans. Which one to choose? Both Technical and Domain Partitioning have advantages and disadvantages, but personally I recommend using: Technical Partitioning when the application to be created is simple and not complex, and also when the number of development team members is not too large. Domain Partitioning when the application to be created is complex and there are many application features. And it is suitable when the development team members are many team divisions based on the type of domain. Layered Architecture Layered Architecture is also known as N -Tier Architecture. This architecture is one of the standard architectures for most applications, where applications are divided technically. Because this architecture is very widely known by software developers, it makes this architecture one of the most widely used choices. Components of Layered Architecture Layered Architecture is technically divided, therefore the components in Layered Architecture are the same as Technical Partition. On average, many divide into 4 layers, Presentation Layer, Business Layer, Persistence Layer and Database Layer. However, it is possible to have more layers when the application is very complex. Tasks of each layer Each layer in Layered Architecture has its own tasks. The Presentation Layer is responsible for handling all user interfaces. The Business Layer is responsible for executing the request logic or business rules that match the request. The Persistence Layer is responsible for interacting with the database to perform data processing in the database. Database Layer is responsible for storing all application data. Layers of Isolation In Layered Architecture, each layer is isolated, and the direction of communication is only with the layer below or above it. That is, for example, when the Presentation Layer wants to retrieve Product data, the Presentation Layer will send a request to the Business Layer, then it will retrieve the data to the Persistence Layer and then enter the Database Layer. It is not recommended to directly access from the Presentation Layer directly to the Database Layer. Example After knowing how Layered Architecture works, we can easily describe the flow that must be made when creating an application. For example, we want to display the Product page, but in the Product page we also want to display the Seller data. Then we can create an application flow as in the next diagram. Considerations Layered Architecture is one of the most widely understood and used architectures. Use Layered Architecture if we are still confused about what architecture to use, because this is a good architecture to start the application. But don’t use Layered Architecture when the division of teams in the company is based on domains, it is more suitable to use Distributed Architecture which we will discuss in the next materials. Model-View-Controller Architecture Model View Controller (MVC) Architecture is one of the most popular architectures when creating the Web. MVC is similar to Layered Architecture, only the layers are different. In MVC, the center of interaction between layers is usually done by the Controller. Tasks of Each Layer In MVC, each layer has its own tasks. Controller is the layer responsible for receiving requests and executing the logic and business rules that occur in the application. Model is the layer responsible for representing the data in the database and also interacting with the database. View is a layer that contains templates for displaying web pages. Database is a layer for storing application data. Example Suppose we have a web where there is one web page that needs to display wishlist data. On that page, in addition to the wishlist data, we also have to display the product details contained in the wishlist.\nConsiderations MVC is the first choice when we want to create a web application. Many web frameworks automatically use this architecture such as Laravel, NestJS, Rails, Django, and others. But when we create a RESTful API for example, we are not obliged to follow the MVC rules, because usually we don’t need a View layer. In this case, we can just combine this MVC architecture with Layered Architecture. Hexagonal Architecture One of the problems when using Layered Architecture is that changes in the type of technology used, will complicate development. For example, when we have to change the database technology used, there will automatically be a major overhaul of the Persistence Layer and Database Layer program code, which may cause an overhaul of the Business Layer as well. Hexagonal Architecture is an architecture developed from Layered Architecture, but better when handling technological changes that occur. Hexagonal Architecture is also known as Port \u0026 Adapter Architecture. Ports and Adapters Hexagonal Architecture was actually introduced under the name Pert \u0026 Adapter Architecture, but is currently more popular as Hexagonal Architecture. Port is a technology-agnostic OOP (Object Oriented Programming) Interface, which is used by application code to communicate with other parties. An Adapter is the part that interacts directly through the Port, and uses a predefined technology. Application Layer In Hexagonal Architecture, the Application Layer will contain business logic and rules, where the code created will interact only with the Port, without knowing which Adapter is used. This is to be technology agnostic, so that when the Adapter is changed, the Application Layer does not need to change. In addition, within the Application Layer, there is a Domain Layer, which contains a representation of the application domain data. The Driving part, usually called User Interface/Transport Layer/Gateway, is the source of incoming requests to the application. The Driven part, usually called Infrastructure/Data Source/External Interfaces, is the target of data leaving the application. Clean Architecture Nowadays, Clean Architecture is also famous. Don’t be confused if you have to choose Hexagonal Architecture or Clean Architecture. Actually Clean Architecture is not much different from Hexagonal Architecture, even the author of the Clean Architecture book has explained that one of the Clean Architecture references is from Hexagonal Architecture. Example Suppose we have an online store Web application, where we will create a payment page. Where when making a payment data besides being stored in the database, it will be sent to the Payment Gateway. Considerations Hexagonal Architecture is a good architecture to use when we are going to create complex applications and so that the application is technology agnostic so that it can be easily replaced. However, developing Hexagonal Architecture is not as easy as Layered Architecture, so if the developer is not familiar with Hexagonal Architecture, it can be constrained during the development process. Microkernel Architecture Microkernel Architecture is very flexible and extensible, so developers can easily add features to applications in the form of extensions or plug-ins, without fear of disrupting the functionality of the application itself. Therefore, Microkernel Architecture is also often referred to as Plug-in Architecture. Microkernel Architecture is widely used in desktop-based applications, for example Visual Studio, Eclipse, and others, where there are many extensions or plug-ins available for these applications. Topology In Microkernel Architecture, there are only two layers, Core System and Plugin Modules. Application logic in Microkernel Architecture is usually placed in Plugins, so this architecture looks like Hexagonal Architecture, but it is not. In Hexagonal Architecture, application logic is placed in the application, while in Microkernel Architecture, application logic details are in each respective Plugin. Considerations Microkernel Architecture is very popular when creating plugin-based Desktop applications, such as Visual Studio, Eclipse, IntelliJ IDEA Ghkan like Browser. Use Microkernel Architecture if we really want to create a Plugin-based application. One of the advantages of Microkernel Architecture is that other people can contribute to creating Plugins for our applications. Client-Server Architecture Client-Server Architecture is one of the Distributed System Architectures that is widely known and used. This architecture is very simple, where there are Client and Server applications that interact with each other. Usually communication between Client and Server uses a TCP/IP network, although it is possible to use other networks such as UDP. Topology Client is an application used by users and interacts directly with users, Usually Client applications are applications based on user interfaces, be it Web, Desktop or Terminal-based, Client will send all requests requested by the user to the Server application Server is the core of the application, where all logic and business rules are carried out on the Server, Server will execute commands requested by the Client, and return the requested data to the Client The advantage of using Client-Server Architecture is that we can run many Client type applications using only one Server application Example Client-Server Architecture is an architecture that is currently widely used, maybe even unconsciously, we have used this architecture. When we create a Mobile application and then connect to the RESTful API, it is actually a Client-Server Architecture. Considerations When we want to create an application, which wants to separate the Client application, or even create many types of Client applications, then the Client-Server architecture is very suitable for use. However, if we want to create a standalone application, do not need to store data on the Server, then we do not need to create a Client-Server application, for example an editor application for Photos, Videos and the like. Master-Slave Architecture Master-Slave Architecture is an architecture where applications can distribute all their work to other applications. The application that commands the application is called the Master, and the application that receives the command is called the Slave. Just like the Client-Server Architecture, usually the Master and Slave communication uses a TCP/IP network. Topology Usually, all requests to the application will go through the Master application. All work received by the Master will usually be distributed to the Slave application. That way, work can be faster because it can be done by many Slave applications. In the diagram, we only create 3 Slave applications, but in reality, there is no limit to the number of Slave applications. Fault Tolerance One of the advantages of Master-Slave Architecture is Fault Tolerance, where when an error occurs that causes one of the Slave applications to die, the work can still be done by other Slave applications. Likewise, when a problem occurs that causes the Master application to die, one of the Slaves will automatically be promoted to become the new Master. Master-Master Architecture One of the disadvantages of Master-Slave Architecture is that all requests must go through the Master application, so when there is a delay in the Master application, all users will automatically feel the impact, even though the Slave application may not be slow. In such cases, there is also Master-Master Architecture, which is an improvement on Master-Slave Architecture. What distinguishes Master-Master Architecture is that all applications can run as Master, so they can receive requests from users independently And because all applications are Master, each application can send requests to other applications, when for example the application has handled too many requests from users. Replication What needs to be remembered in Master-Slave/Master-Master Architecture, usually data in the application is always replicated/duplicated to all Slaves/Masters. This is so that the data is always the same, so that the work done by all Slave/Master applications will always be consistent. Example Master-Slave/Master-Master Architecture should not be used when creating information system applications, this architecture is often used when we create stateful applications! (storing data) such as database systems. Almost most database system applications such as MySQL, PostgreSQL, MongoDB implement the Master-Slave Architecture Or like the Elasticsearch and Cassandra database system applications, which use the Master-Master Architecture. Considerations Use the Master-Slave/Master-Master architecture when we want to create a stateful application! (save data) If we create a stateless application (do not store data), then it is recommended not to use this architecture. Peer-to-Peer Architecture Peer-to-Peer Architecture is an architecture that is almost similar to Client-Server Architecture. However, in Peer-to-Peer, all applications can be Clients and Servers simultaneously. Usually the application logic will be centralized in the Server application, in Peer-to-Peer, the application logic is not centralized in one application, all applications can be Servers and Clients at the same time. Topology In Peer-to-Peer Architecture it seems simple, but in fact this architecture is very complex. Each Peer can be a Client that makes requests to other Peers, or even become a Server at the same time by sending responses to other Peers. Therefore, creating a Peer-to-Peer Architecture application is very complex because each Peer must know when there is a new Peer, because in reality new Peers can come and go at any time. vs Master-Master Architecture What is the difference between Peer-to-Peer Architecture and Master-Master Architecture? In Peer-to-Peer, each Peer can be a Client or Server. While in Master-Master, each Master is a Server, usually the Client is a separate application and connected to the Master-Master with a Client-Server architecture. Example Peer-to-Peer is widely used for file sharing applications such as Torrent, for example, where everyone can share files, while requesting files from other Peers in their Torrent network. In addition, Peer-to-Peer is also often used in Cryptocurrency where all data is distributed across all Peer applications to keep data safe because to change data, we have to change all data in all Peers, and that is very difficult to do. Considerations Peer-to-Peer Architecture may look very attractive, but this is a type of architecture that is rarely used, except in types of applications that require decentralized logic. Peer-to-Peer Architecture is also a very scalable architecture, because it is difficult for system failures to occur because all logic is distributed across all Peers The disadvantage is, because we cannot be the quality of resources in each Peer, so, it is likely that the quality and speed of the application cannot be maintained properly, especially if the Peer runs on hardware with insufficient resources. Microservices Architecture Microservices Architecture is a type of architecture that is currently widely used by many people. However, this architecture is not a simple type of architecture, it is a complex type of architecture. In Microservices Architectures, the system will be created in a number of small applications or called Services, and used to complete certain specific tasks only. In addition, in this architecture, each Service will be deployed and run independently In this architecture, it is not strange if a system has hundreds or even thousands of independent Services, this is because each Service does have its own task. Topology Usually in Microservices Architecture, each Service will run independently and have its own database, not sharing the database with other Services. Usually, each Service will not be exposed openly to users, but users will go through the API Gateway, which is an application that acts as a gateway to receive requests and forward them to the intended Service. Because each Service has its own tasks, it is not uncommon for the databases used to be different, this is because usually the Service will use a database that is in accordance with the tasks that must be done. Bounded Context As previously explained, each Service will have and manage its own database. This means that the database and table can only be accessed by the Service For example, when we have a Service that is used to manage Seller data, then the Seller Service can only manage the Seller data. This concept is called Bounded Context, which was introduced by Eric Evans in the Domain-Driven Design book. Communication Between Services With Bounded Context, it means that no one can access the Seller database directly from another Service except the Seller Service. If there is another Service that requires Seller data, then the other Service must request Seller data from Seller Service, using a predetermined communication method, for example RESTful API (Client-Server Architecture). Example On the online store web page, we want to display detailed Product data. However, on the Product detail data page, in addition to Product information, we also want to display data from the Seller who sells the Product. In this case, we can take Product data to Product Service, then Product Service requests Seller data from Seller Service. Supporters To use Microservices Architecture usually does not only involve the programmer team.\nThere are many things that must be changed such as infrastructure and product/business teams.\nThis is because usually in Microservice Architecture, the division of Services will be done based on the business domain, so it is not easy to create small applications.\nIn some cases, errors in creating Service types can complicate the development team, therefore Domain Experts or those who are experts in their fields in terms of business are needed.\nConsiderations Microservice Architecture is usually used in large companies with large development teams, this is because this architecture requires a lot of work other than application creation, such as infrastructure, automation, deployment and others. Do not use this architecture if the team is still small, we can start with Monolith Architecture and Layered Architecture, if it is time to need rapid team scaling, we can consider using Microservices Architecture. Event-Driven Architecture Microservices Architecture Problems With the increasing use of Microservices Architecture, finally there is one problem that is often experienced by users of this architecture, namely the dependency between Services. For example, in the previous case, when the Seller Service has a problem, for example it dies, then we cannot see the Product data, this is because the Product Service needs to call the Seller Service when it wants to display Product data. Event-Driven Architecture Event-Driven Architecture is an architecture that uses Async Process to communicate with each other between Services. Usually, in this architecture, the Service will send every data change that occurs in the Service to an application called Message Broker in the form of Event data. We call the sender of Event data Producer/Publisher. The service that needs its Event data will take the data from the Message Broker. We call the recipient of Event data Consumer/Listener. Duplicate Data As we already know, in Microservices Architecture there is a Bounded Context rule, where data can only be accessed by the Service itself. In the case of Event-Driven Architecture, because we will not call Sync to Other Services (such as using API Call), then usually the Service will consume event data and duplicate the data needed in the Service database. In the previous case, for example, the Product Service will consume Seller Event data, then save the Seller data to the Product database as duplicate data. Considerations Event-Driven Architecture is currently widely used, because of the problems that occur in Microservices Architecture, but it should be noted, there are also consequences that occur when we use Async Process. In the previous case, we must ensure that the Seller Event data is received properly by the Product Service, if it fails automatically the Seller data will not be in the Product database. Async Process will also cause the process to be delayed, therefore sometimes users do not receive results in real time, because the Async Process has not finished When a problem occurs in the Async Process, searching for problems is more difficult than the Sync Process in the Microservices architecture. Pipeline Architecture Pipeline Architecture is an architecture that is closely related to Data Stream. In some cases, sometimes we encounter data sources that come in non-stop, for example user activity log data. In cases like this, storing data in a database will be very difficult to process, because incoming data is usually in large quantities and continuously. Pipeline Architecture is an architecture where we utilize Message Queue like Message Broker as a place for data flow, and we can focus on creating Filters to process the data. Topology In Pipeline Architecture, the main focus is the Filter process for messages. There is no rule for the Filter process whether it must be in the same or different applications, so there is no right or wrong. Filters are usually processes that are carried out from receiving input data, processing data, and ending with producing output data. Cloud Function This Pipeline Architecture is now very popular in Cloud Providers such as Google Cloud or Amazon Web Service. These Cloud Providers now have features for Cloud Function, which can be used as Filters in Pipeline Architecture. One of the advantages of using Cloud Function, we only need to pay when the Filter processes data. Data Pipeline Pipeline Architecture is also often used in data processing, or often known as Data Pipeline. In Data Pipeline, there is usually a Source (data source), Destination (final destination of data), and also Processing (data processing). Example We want to create a report on the number of daily visitors to our website, where in the report, we can see the number of visitors based on the country of the visitor In this case we can use Pipeline Architecture. Starting from every visit data to our website, we will send it as an event to the Message Broker, then we will create a filter, from a filter to detect the IP address, a filter to get the country based on the IP, and a filter to group by country. Considerations Pipeline Architecture is a very suitable architecture when we want to do very long and gradual processing. Pipeline Architecture can take a very long time to process, depending on how long the Filter is, therefore it is not suitable for doing work that requires real time. Space-Based Architecture Triangle-Shaped In certain cases, there are types of applications that usually have unexpected visitor traffic, such as flash sale websites, ticket sales or bidding. The architectures that we discussed earlier, we can actually use to create these types of applications, but in certain cases, sometimes we end up getting triangle-shaped problems. Triangle-Shaped Topology Triangle-Shaped Topology is a condition where we do scalability by increasing the number of applications when there is a slowdown in our system. In cases when we create a website, increasing the number of web servers is usually very easy, because it only provides a website user interface, then usually the slowdown will move to the Backend server, for example in the RESTful API. Next, we will usually add the number of RESTful API servers, but not as many as Web Servers, because usually the application is heavier and requires more resources, then the slowness will move to the Database. In cases like this, adding servers to the database is not easy, not as flexible as Web Servers and RESTful APIs, because the database is a stateful application (storing data). Space-Based Architecture Space-Based Architecture is an architecture specifically designed for cases like this, where we need good scalability and performance for the application.\nSpace-Based Architecture solves this problem by removing the database from the application transaction process and replacing it with shared memory (Data Grid).\nHigh Scalability is achieved by connecting all applications to shared memory (Data Grid) synchronously, and asynchronously the data in shared memory will be synced to the database,\nTopology In Spaced-Based Architecture, the application we create is called a Processing Unit. In the Processing Unit, there is our application logic and also contains the In Memory Data Grid which is used as a replacement for the Database. Usually there is a Data Replication Engine which is used to synchronize all data in the In Memory Data Grid for all Processing units assisted by the Data Grid Cluster. If we want, we can async save the changes that occur in the In Memory Data Grid to the Database. Data Grid Example Usually Data Grid does not need to be created manually by application developers, just like the Database, we can use the Data Grid application that is already available, for example. Hazelcast. Apache Ignite. Oracle Coherence. And others. Considerations Spaced-Based Architecture is a very complex solution to achieve excellent scalability. However, although this solution is very good, sometimes this solution is not the best, we must see many considerations when using this architecture. For example, if our data is too large, it will be difficult to use this architecture, because all data must be moved to memory, which certainly requires a very large cost. Because of the complexity and high cost of this solution, we must also consider the costs that must be incurred to use this architecture. Conclusion Software Architecture Patterns are not a rigid solution where we have to choose one. We can combine several Patterns that suit our needs. For example, we can combine Microservices and Event-Driven, or Monolith with Layered, Microservices with Layered, and so on. Other Software Architecture Patterns This class does not discuss all existing Software Architecture Patterns, only those that are often used. Technology, especially in Software Design, is always evolving over time, in the early 2000s not many people used Microservices, but now almost all large companies use them. There are still many patterns that have not been discussed, and can be studied independently, such as: Onion Architecture, Screaming Architecture, Event-Bus Architecture, and many others. Source: ","wordCount":"4709","inLanguage":"en","image":"https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph","datePublished":"2025-04-29T20:27:25+07:00","dateModified":"2025-04-29T20:27:25+07:00","author":{"@type":"Person","name":"Ahmad Adillaumam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wewnumam.github.io/articles/software-architecture-patterns/"},"publisher":{"@type":"Organization","name":"Ahmad Adillaumam","logo":{"@type":"ImageObject","url":"https://wewnumam.github.io/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wewnumam.github.io/ accesskey=h title="Ahmad Adillaumam (Alt + H)"><img src=https://wewnumam.github.io/favicon.png alt aria-label=logo height=35>Ahmad Adillaumam</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wewnumam.github.io/id/ title=🆔 aria-label=:id:>Id</a></li></ul></div></div><ul id=menu><li><a href=https://wewnumam.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://wewnumam.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://wewnumam.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://wewnumam.github.io/about/ title="About Me"><span>About Me</span></a></li><li><a href=https://github.com/wewnumam/gtstmm-gamedev-roadmap title="Gamedev Roadmap"><span>Gamedev Roadmap</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://gist.github.com/wewnumam/e0fa4b6e659ad5d08e5a373198909ddb title=Bookmarks><span>Bookmarks</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wewnumam.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://wewnumam.github.io/articles/>Articles</a></div><h1 class="post-title entry-hint-parent">Software Architecture Patterns</h1><div class=post-meta><span title='2025-04-29 20:27:25 +0700 +0700'>29 April 2025</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4709 words&nbsp;·&nbsp;Ahmad Adillaumam&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://wewnumam.github.io/id/articles/software-architecture-patterns/>Id</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wewnumam/wewnumam.github.io/tree/main/content/articles/software-architecture-patterns.en.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#software-architecture-patterns>Software Architecture Patterns</a></li><li><a href=#purpose-of-architecture-patterns>Purpose of Architecture Patterns</a></li></ul><ul><li><a href=#monolithic-architectures>Monolithic Architectures</a></li><li><a href=#distributed-architecture>Distributed Architecture</a></li><li><a href=#which-one-to-choose>Which one to choose?</a></li></ul><ul><li><a href=#technical-partitioning>Technical Partitioning</a></li><li><a href=#domain-partitioning>Domain Partitioning</a></li><li><a href=#which-one-to-choose-1>Which one to choose?</a></li></ul><ul><li><a href=#components-of-layered-architecture>Components of Layered Architecture</a></li><li><a href=#tasks-of-each-layer>Tasks of each layer</a></li><li><a href=#layers-of-isolation>Layers of Isolation</a></li><li><a href=#example>Example</a></li><li><a href=#considerations>Considerations</a></li></ul><ul><li><a href=#tasks-of-each-layer-1>Tasks of Each Layer</a></li><li><a href=#example-1>Example</a></li><li><a href=#considerations-1>Considerations</a></li></ul><ul><li><a href=#ports-and-adapters>Ports and Adapters</a></li><li><a href=#application-layer>Application Layer</a></li><li><a href=#clean-architecture>Clean Architecture</a></li><li><a href=#example-2>Example</a></li><li><a href=#considerations-2>Considerations</a></li></ul><ul><li><a href=#topology>Topology</a></li><li><a href=#considerations-3>Considerations</a></li></ul><ul><li><a href=#topology-1>Topology</a></li><li><a href=#example-3>Example</a></li><li><a href=#considerations-4>Considerations</a></li></ul><ul><li><a href=#topology-2>Topology</a></li><li><a href=#fault-tolerance>Fault Tolerance</a></li><li><a href=#master-master-architecture>Master-Master Architecture</a></li><li><a href=#replication>Replication</a></li><li><a href=#example-4>Example</a></li><li><a href=#considerations-5>Considerations</a></li></ul><ul><li><a href=#topology-3>Topology</a></li><li><a href=#vs-master-master-architecture>vs Master-Master Architecture</a></li><li><a href=#example-5>Example</a></li><li><a href=#considerations-6>Considerations</a></li></ul><ul><li><a href=#topology-4>Topology</a></li><li><a href=#bounded-context>Bounded Context</a></li><li><a href=#communication-between-services>Communication Between Services</a></li><li><a href=#example-6>Example</a></li><li><a href=#supporters>Supporters</a></li><li><a href=#considerations-7>Considerations</a></li></ul><ul><li><a href=#microservices-architecture-problems>Microservices Architecture Problems</a></li><li><a href=#event-driven-architecture-1>Event-Driven Architecture</a></li><li><a href=#duplicate-data>Duplicate Data</a></li><li><a href=#considerations-8>Considerations</a></li></ul><ul><li><a href=#topology-5>Topology</a></li><li><a href=#cloud-function>Cloud Function</a></li><li><a href=#data-pipeline>Data Pipeline</a></li><li><a href=#example-7>Example</a></li><li><a href=#considerations-9>Considerations</a></li></ul><ul><li><a href=#triangle-shaped>Triangle-Shaped</a></li><li><a href=#triangle-shaped-topology>Triangle-Shaped Topology</a></li><li><a href=#space-based-architecture-1>Space-Based Architecture</a></li><li><a href=#topology-6>Topology</a></li><li><a href=#data-grid-example>Data Grid Example</a></li><li><a href=#considerations-10>Considerations</a></li></ul><ul><li><a href=#other-software-architecture-patterns>Other Software Architecture Patterns</a></li></ul></nav></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><ul><li>It is common for programmers to create software without careful preparation.</li><li>This sometimes makes the software difficult to maintain and develop when it has already been made.</li><li>Therefore, before making a large software, one of the things that must be done is to choose the architecture that will be used.</li><li>In choosing a software architecture, we must understand its advantages and disadvantages, so that it helps in the creation of the software to be carried out.</li></ul><h2 id=software-architecture-patterns>Software Architecture Patterns<a hidden class=anchor aria-hidden=true href=#software-architecture-patterns>#</a></h2><ul><li>Architecture Patterns are a collection of architectural styles in software development.</li><li>There are many Architecture Patterns, and each pattern has its own advantages and disadvantages. In Architecture Patterns there is no right and wrong, but whether it fits or not.</li><li>Programmers need to know about this material so that they can determine what pattern to use when creating software.</li></ul><h2 id=purpose-of-architecture-patterns>Purpose of Architecture Patterns<a hidden class=anchor aria-hidden=true href=#purpose-of-architecture-patterns>#</a></h2><ul><li>Each Architecture Pattern has characteristics such as easy to develop, scalable and easy to maintain.</li><li>The hope is that by using the right Architecture Pattern when making software, the results of the software we make will be easy to develop in the future.</li></ul><h1 id=architecture-classification>Architecture Classification<a hidden class=anchor aria-hidden=true href=#architecture-classification>#</a></h1><ul><li>Software Architecture Patterns are broadly divided into two classifications, Monolithic and Distribute.</li><li>Monolithic is a single deployment unit or runs in one application.</li><li>Distributed is multiple deployment units, usually consisting of several applications.</li></ul><h2 id=monolithic-architectures>Monolithic Architectures<a hidden class=anchor aria-hidden=true href=#monolithic-architectures>#</a></h2><ul><li>Monolithic Architecture is generally very simple compared to Distributed Architecture.</li><li>Monolithic application design is simpler and easier to implement.</li><li>Applications that use Monolithic Architecture will be very fast to build and distribute.
<img alt="Monolithic Architectures" loading=lazy src=https://i.imgur.com/YQkdFLv.png></li></ul><h2 id=distributed-architecture>Distributed Architecture<a hidden class=anchor aria-hidden=true href=#distributed-architecture>#</a></h2><ul><li>Distributed Architecture usually consists of several applications working simultaneously, in contrast to Monolithic applications which are only one application.</li><li>Usually in Distributed Architecture, each application unit is called a Service.</li><li>Distributed Architecture development is more complex than Monolithic Architecture, but offers advantages such as fault tolerance, for example when one service fails, other services can still run normally.</li></ul><p><img alt="Distributed Architecture" loading=lazy src=https://i.imgur.com/CAHCQzg.png></p><h2 id=which-one-to-choose>Which one to choose?<a hidden class=anchor aria-hidden=true href=#which-one-to-choose>#</a></h2><ul><li>When making applications, sometimes we are confused about whether to use Monolithic or Distributed architecture?</li><li>If the application we are going to create is simple or still unclear in terms of business requirements, it is highly recommended to use Monolithic, because it is easy to create.</li><li>But if the application we are going to make is very clear, and also requires good scalability, including good fault tolerance, then we can use Distributed architecture.</li></ul><h1 id=architecture-partitioning>Architecture Partitioning<a hidden class=anchor aria-hidden=true href=#architecture-partitioning>#</a></h1><ul><li>In addition to the classification of monolithic or distributed, software architecture can also be seen in its partition structure.</li><li>Software architecture, be it monolithic or distributed, can be partitioned based on technical or domain.</li><li>Partitioning by structure can be used in monolithic or distributed.</li></ul><h2 id=technical-partitioning>Technical Partitioning<a hidden class=anchor aria-hidden=true href=#technical-partitioning>#</a></h2><ul><li>Technical Partitioning architecture divides the components in the system or application technically.</li><li>An example of a classic architecture that is often used is Layered (N-Tier) Architecture.</li><li>In Technical Partitioning, the components in the system are grouped technically, for example :<ul><li>Presentation Layer is the component that handles the user interface.</li><li>Business Layer, a component that handles business logic and rules.</li><li>Persistence Layer, a component that handles interaction with the database system.</li><li>Database Layer, a component for storing data.</li></ul></li></ul><p><img alt="Technical Partitioning" loading=lazy src=https://i.imgur.com/jFaaqq7.png></p><h2 id=domain-partitioning>Domain Partitioning<a hidden class=anchor aria-hidden=true href=#domain-partitioning>#</a></h2><ul><li>In contrast to Technical Partitioning, in Domain Partitioning, the division of the component structure in the system is grouped based on the Domain / Feature / Department in business.</li><li>This means that all Technical Partitioning such as Presentation, Business Logic, Persistence, are combined in the system domain.</li><li>Domain-based system partitioning has been popular since it was introduced in a book titled “Domain Driven Design” by Eric Evans.</li></ul><p><img alt="Domain Partitioning" loading=lazy src=https://i.imgur.com/UA9tXUz.png></p><h2 id=which-one-to-choose-1>Which one to choose?<a hidden class=anchor aria-hidden=true href=#which-one-to-choose-1>#</a></h2><ul><li>Both Technical and Domain Partitioning have advantages and disadvantages, but personally I recommend using:</li><li>Technical Partitioning when the application to be created is simple and not complex, and also when the number of development team members is not too large.</li><li>Domain Partitioning when the application to be created is complex and there are many application features. And it is suitable when the development team members are many team divisions based on the type of domain.</li></ul><h1 id=layered-architecture>Layered Architecture<a hidden class=anchor aria-hidden=true href=#layered-architecture>#</a></h1><ul><li>Layered Architecture is also known as N -Tier Architecture.</li><li>This architecture is one of the standard architectures for most applications, where applications are divided technically.</li><li>Because this architecture is very widely known by software developers, it makes this architecture one of the most widely used choices.</li></ul><h2 id=components-of-layered-architecture>Components of Layered Architecture<a hidden class=anchor aria-hidden=true href=#components-of-layered-architecture>#</a></h2><ul><li>Layered Architecture is technically divided, therefore the components in Layered Architecture are the same as Technical Partition.</li><li>On average, many divide into 4 layers, Presentation Layer, Business Layer, Persistence Layer and Database Layer. However, it is possible to have more layers when the application is very complex.</li></ul><p><img alt="ayered Architecture Components" loading=lazy src=https://i.imgur.com/JrUPelT.png></p><h2 id=tasks-of-each-layer>Tasks of each layer<a hidden class=anchor aria-hidden=true href=#tasks-of-each-layer>#</a></h2><ul><li>Each layer in Layered Architecture has its own tasks.</li><li>The Presentation Layer is responsible for handling all user interfaces.</li><li>The Business Layer is responsible for executing the request logic or business rules that match the request.</li><li>The Persistence Layer is responsible for interacting with the database to perform data processing in the database.</li><li>Database Layer is responsible for storing all application data.</li></ul><h2 id=layers-of-isolation>Layers of Isolation<a hidden class=anchor aria-hidden=true href=#layers-of-isolation>#</a></h2><ul><li>In Layered Architecture, each layer is isolated, and the direction of communication is only with the layer below or above it.</li><li>That is, for example, when the Presentation Layer wants to retrieve Product data, the Presentation Layer will send a request to the Business Layer, then it will retrieve the data to the Persistence Layer and then enter the Database Layer.</li><li>It is not recommended to directly access from the Presentation Layer directly to the Database Layer.</li></ul><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><ul><li>After knowing how Layered Architecture works, we can easily describe the flow that must be made when creating an application.</li><li>For example, we want to display the Product page, but in the Product page we also want to display the Seller data.</li><li>Then we can create an application flow as in the next diagram.</li></ul><p><img alt="Layered Architecture Flow Example" loading=lazy src=https://i.imgur.com/UbjXlTr.png></p><h2 id=considerations>Considerations<a hidden class=anchor aria-hidden=true href=#considerations>#</a></h2><ul><li>Layered Architecture is one of the most widely understood and used architectures.</li><li>Use Layered Architecture if we are still confused about what architecture to use, because this is a good architecture to start the application.</li><li>But don&rsquo;t use Layered Architecture when the division of teams in the company is based on domains, it is more suitable to use Distributed Architecture which we will discuss in the next materials.</li></ul><h1 id=model-view-controller-architecture>Model-View-Controller Architecture<a hidden class=anchor aria-hidden=true href=#model-view-controller-architecture>#</a></h1><ul><li>Model View Controller (MVC) Architecture is one of the most popular architectures when creating the Web.</li><li>MVC is similar to Layered Architecture, only the layers are different.</li><li>In MVC, the center of interaction between layers is usually done by the Controller.</li></ul><p><img alt="Model-View-Controller Architecture" loading=lazy src=https://i.imgur.com/TSq4w4X.png></p><h2 id=tasks-of-each-layer-1>Tasks of Each Layer<a hidden class=anchor aria-hidden=true href=#tasks-of-each-layer-1>#</a></h2><ul><li>In MVC, each layer has its own tasks.</li><li>Controller is the layer responsible for receiving requests and executing the logic and business rules that occur in the application.</li><li>Model is the layer responsible for representing the data in the database and also interacting with the database.</li><li>View is a layer that contains templates for displaying web pages.</li><li>Database is a layer for storing application data.</li></ul><h2 id=example-1>Example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h2><p>Suppose we have a web where there is one web page that needs to display wishlist data. On that page, in addition to the wishlist data, we also have to display the product details contained in the wishlist.</p><p><img alt="Example of Model-View-Controller Architecture" loading=lazy src=https://i.imgur.com/7Fh4CWw.png></p><h2 id=considerations-1>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-1>#</a></h2><ul><li>MVC is the first choice when we want to create a web application.</li><li>Many web frameworks automatically use this architecture such as Laravel, NestJS, Rails, Django, and others.</li><li>But when we create a RESTful API for example, we are not obliged to follow the MVC rules, because usually we don&rsquo;t need a View layer. In this case, we can just combine this MVC architecture with Layered Architecture.</li></ul><h1 id=hexagonal-architecture>Hexagonal Architecture<a hidden class=anchor aria-hidden=true href=#hexagonal-architecture>#</a></h1><ul><li>One of the problems when using Layered Architecture is that changes in the type of technology used, will complicate development.</li><li>For example, when we have to change the database technology used, there will automatically be a major overhaul of the Persistence Layer and Database Layer program code, which may cause an overhaul of the Business Layer as well.</li><li>Hexagonal Architecture is an architecture developed from Layered Architecture, but better when handling technological changes that occur.</li><li>Hexagonal Architecture is also known as Port & Adapter Architecture.</li></ul><p><img alt="Hexagonal Architecture" loading=lazy src=https://i.imgur.com/g98YhPu.png></p><h2 id=ports-and-adapters>Ports and Adapters<a hidden class=anchor aria-hidden=true href=#ports-and-adapters>#</a></h2><ul><li>Hexagonal Architecture was actually introduced under the name Pert & Adapter Architecture, but is currently more popular as Hexagonal Architecture.</li><li>Port is a technology-agnostic OOP (Object Oriented Programming) Interface, which is used by application code to communicate with other parties.</li><li>An Adapter is the part that interacts directly through the Port, and uses a predefined technology.</li></ul><p><img alt="Port and Adapter" loading=lazy src=https://i.imgur.com/AAV5hSj.png></p><h2 id=application-layer>Application Layer<a hidden class=anchor aria-hidden=true href=#application-layer>#</a></h2><ul><li>In Hexagonal Architecture, the Application Layer will contain business logic and rules, where the code created will interact only with the Port, without knowing which Adapter is used.</li><li>This is to be technology agnostic, so that when the Adapter is changed, the Application Layer does not need to change.</li><li>In addition, within the Application Layer, there is a Domain Layer, which contains a representation of the application domain data.</li><li>The Driving part, usually called User Interface/Transport Layer/Gateway, is the source of incoming requests to the application.</li><li>The Driven part, usually called Infrastructure/Data Source/External Interfaces, is the target of data leaving the application.</li></ul><p><img alt="Application Layer" loading=lazy src=https://i.imgur.com/gBwZEBA.png></p><h2 id=clean-architecture>Clean Architecture<a hidden class=anchor aria-hidden=true href=#clean-architecture>#</a></h2><ul><li>Nowadays, Clean Architecture is also famous.</li><li>Don&rsquo;t be confused if you have to choose Hexagonal Architecture or Clean Architecture.</li><li>Actually Clean Architecture is not much different from Hexagonal Architecture, even the author of the Clean Architecture book has explained that one of the Clean Architecture references is from Hexagonal Architecture.</li></ul><h2 id=example-2>Example<a hidden class=anchor aria-hidden=true href=#example-2>#</a></h2><ul><li>Suppose we have an online store Web application, where we will create a payment page.</li><li>Where when making a payment data besides being stored in the database, it will be sent to the Payment Gateway.</li></ul><p><img alt="Example of Hexagonal Architecture" loading=lazy src=https://i.imgur.com/hu9jRuY.png></p><h2 id=considerations-2>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-2>#</a></h2><ul><li>Hexagonal Architecture is a good architecture to use when we are going to create complex applications and so that the application is technology agnostic so that it can be easily replaced.</li><li>However, developing Hexagonal Architecture is not as easy as Layered Architecture, so if the developer is not familiar with Hexagonal Architecture, it can be constrained during the development process.</li></ul><h1 id=microkernel-architecture>Microkernel Architecture<a hidden class=anchor aria-hidden=true href=#microkernel-architecture>#</a></h1><ul><li>Microkernel Architecture is very flexible and extensible, so developers can easily add features to applications in the form of extensions or plug-ins, without fear of disrupting the functionality of the application itself.</li><li>Therefore, Microkernel Architecture is also often referred to as Plug-in Architecture.</li><li>Microkernel Architecture is widely used in desktop-based applications, for example Visual Studio, Eclipse, and others, where there are many extensions or plug-ins available for these applications.</li></ul><p><img alt="Microkernel Architecture" loading=lazy src=https://i.imgur.com/tM4zGf2.png></p><h2 id=topology>Topology<a hidden class=anchor aria-hidden=true href=#topology>#</a></h2><ul><li>In Microkernel Architecture, there are only two layers, Core System and Plugin Modules.</li><li>Application logic in Microkernel Architecture is usually placed in Plugins, so this architecture looks like Hexagonal Architecture, but it is not.</li><li>In Hexagonal Architecture, application logic is placed in the application, while in Microkernel Architecture, application logic details are in each respective Plugin.</li></ul><h2 id=considerations-3>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-3>#</a></h2><ul><li>Microkernel Architecture is very popular when creating plugin-based Desktop applications, such as Visual Studio, Eclipse, IntelliJ IDEA Ghkan like Browser.</li><li>Use Microkernel Architecture if we really want to create a Plugin-based application.</li><li>One of the advantages of Microkernel Architecture is that other people can contribute to creating Plugins for our applications.</li></ul><h1 id=client-server-architecture>Client-Server Architecture<a hidden class=anchor aria-hidden=true href=#client-server-architecture>#</a></h1><ul><li>Client-Server Architecture is one of the Distributed System Architectures that is widely known and used.</li><li>This architecture is very simple, where there are Client and Server applications that interact with each other.</li><li>Usually communication between Client and Server uses a TCP/IP network, although it is possible to use other networks such as UDP.</li></ul><p><img alt="Client-Server Architecture" loading=lazy src=https://i.imgur.com/NWSKhhf.png></p><h2 id=topology-1>Topology<a hidden class=anchor aria-hidden=true href=#topology-1>#</a></h2><ul><li>Client is an application used by users and interacts directly with users, Usually Client applications are applications based on user interfaces, be it Web, Desktop or Terminal-based, Client will send all requests requested by the user to the Server application</li><li>Server is the core of the application, where all logic and business rules are carried out on the Server, Server will execute commands requested by the Client, and return the requested data to the Client</li><li>The advantage of using Client-Server Architecture is that we can run many Client type applications using only one Server application</li></ul><h2 id=example-3>Example<a hidden class=anchor aria-hidden=true href=#example-3>#</a></h2><ul><li>Client-Server Architecture is an architecture that is currently widely used, maybe even unconsciously, we have used this architecture.</li><li>When we create a Mobile application and then connect to the RESTful API, it is actually a Client-Server Architecture.</li></ul><p><img alt="Client-Server Architecture Example" loading=lazy src=https://i.imgur.com/mhQdLau.png></p><h2 id=considerations-4>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-4>#</a></h2><ul><li>When we want to create an application, which wants to separate the Client application, or even create many types of Client applications, then the Client-Server architecture is very suitable for use.</li><li>However, if we want to create a standalone application, do not need to store data on the Server, then we do not need to create a Client-Server application, for example an editor application for Photos, Videos and the like.</li></ul><h1 id=master-slave-architecture>Master-Slave Architecture<a hidden class=anchor aria-hidden=true href=#master-slave-architecture>#</a></h1><ul><li>Master-Slave Architecture is an architecture where applications can distribute all their work to other applications.</li><li>The application that commands the application is called the Master, and the application that receives the command is called the Slave.</li><li>Just like the Client-Server Architecture, usually the Master and Slave communication uses a TCP/IP network.</li></ul><p><img alt="Master-Slave Architecture" loading=lazy src=https://i.imgur.com/ISP00p4.png></p><h2 id=topology-2>Topology<a hidden class=anchor aria-hidden=true href=#topology-2>#</a></h2><ul><li>Usually, all requests to the application will go through the Master application.</li><li>All work received by the Master will usually be distributed to the Slave application.</li><li>That way, work can be faster because it can be done by many Slave applications.</li><li>In the diagram, we only create 3 Slave applications, but in reality, there is no limit to the number of Slave applications.</li></ul><h2 id=fault-tolerance>Fault Tolerance<a hidden class=anchor aria-hidden=true href=#fault-tolerance>#</a></h2><ul><li>One of the advantages of Master-Slave Architecture is Fault Tolerance, where when an error occurs that causes one of the Slave applications to die, the work can still be done by other Slave applications.</li><li>Likewise, when a problem occurs that causes the Master application to die, one of the Slaves will automatically be promoted to become the new Master.</li></ul><p><img alt="Fault Tolerance" loading=lazy src=https://i.imgur.com/cQ3Accc.png></p><h2 id=master-master-architecture>Master-Master Architecture<a hidden class=anchor aria-hidden=true href=#master-master-architecture>#</a></h2><ul><li>One of the disadvantages of Master-Slave Architecture is that all requests must go through the Master application, so when there is a delay in the Master application, all users will automatically feel the impact, even though the Slave application may not be slow.</li><li>In such cases, there is also Master-Master Architecture, which is an improvement on Master-Slave Architecture.</li><li>What distinguishes Master-Master Architecture is that all applications can run as Master, so they can receive requests from users independently</li><li>And because all applications are Master, each application can send requests to other applications, when for example the application has handled too many requests from users.</li></ul><p><img alt="Master-Master Architecture" loading=lazy src=https://i.imgur.com/kNpvSUc.png></p><h2 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h2><ul><li>What needs to be remembered in Master-Slave/Master-Master Architecture, usually data in the application is always replicated/duplicated to all Slaves/Masters.</li><li>This is so that the data is always the same, so that the work done by all Slave/Master applications will always be consistent.</li></ul><h2 id=example-4>Example<a hidden class=anchor aria-hidden=true href=#example-4>#</a></h2><ul><li>Master-Slave/Master-Master Architecture should not be used when creating information system applications, this architecture is often used when we create stateful applications! (storing data) such as database systems.</li><li>Almost most database system applications such as MySQL, PostgreSQL, MongoDB implement the Master-Slave Architecture</li><li>Or like the Elasticsearch and Cassandra database system applications, which use the Master-Master Architecture.</li></ul><h2 id=considerations-5>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-5>#</a></h2><ul><li>Use the Master-Slave/Master-Master architecture when we want to create a stateful application! (save data)</li><li>If we create a stateless application (do not store data), then it is recommended not to use this architecture.</li></ul><h1 id=peer-to-peer-architecture>Peer-to-Peer Architecture<a hidden class=anchor aria-hidden=true href=#peer-to-peer-architecture>#</a></h1><ul><li>Peer-to-Peer Architecture is an architecture that is almost similar to Client-Server Architecture.</li><li>However, in Peer-to-Peer, all applications can be Clients and Servers simultaneously.</li><li>Usually the application logic will be centralized in the Server application, in Peer-to-Peer, the application logic is not centralized in one application, all applications can be Servers and Clients at the same time.</li></ul><p><img alt="Peer-to-Peer Architecture" loading=lazy src=https://i.imgur.com/QIkp4fF.png></p><h2 id=topology-3>Topology<a hidden class=anchor aria-hidden=true href=#topology-3>#</a></h2><ul><li>In Peer-to-Peer Architecture it seems simple, but in fact this architecture is very complex.</li><li>Each Peer can be a Client that makes requests to other Peers, or even become a Server at the same time by sending responses to other Peers.</li><li>Therefore, creating a Peer-to-Peer Architecture application is very complex because each Peer must know when there is a new Peer, because in reality new Peers can come and go at any time.</li></ul><h2 id=vs-master-master-architecture>vs Master-Master Architecture<a hidden class=anchor aria-hidden=true href=#vs-master-master-architecture>#</a></h2><ul><li>What is the difference between Peer-to-Peer Architecture and Master-Master Architecture?</li><li>In Peer-to-Peer, each Peer can be a Client or Server.</li><li>While in Master-Master, each Master is a Server, usually the Client is a separate application and connected to the Master-Master with a Client-Server architecture.</li></ul><h2 id=example-5>Example<a hidden class=anchor aria-hidden=true href=#example-5>#</a></h2><ul><li>Peer-to-Peer is widely used for file sharing applications such as Torrent, for example, where everyone can share files, while requesting files from other Peers in their Torrent network.</li><li>In addition, Peer-to-Peer is also often used in Cryptocurrency where all data is distributed across all Peer applications to keep data safe because to change data, we have to change all data in all Peers, and that is very difficult to do.</li></ul><h2 id=considerations-6>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-6>#</a></h2><ul><li>Peer-to-Peer Architecture may look very attractive, but this is a type of architecture that is rarely used, except in types of applications that require decentralized logic.</li><li>Peer-to-Peer Architecture is also a very scalable architecture, because it is difficult for system failures to occur because all logic is distributed across all Peers</li><li>The disadvantage is, because we cannot be the quality of resources in each Peer, so, it is likely that the quality and speed of the application cannot be maintained properly, especially if the Peer runs on hardware with insufficient resources.</li></ul><h1 id=microservices-architecture>Microservices Architecture<a hidden class=anchor aria-hidden=true href=#microservices-architecture>#</a></h1><ul><li>Microservices Architecture is a type of architecture that is currently widely used by many people. However, this architecture is not a simple type of architecture, it is a complex type of architecture.</li><li>In Microservices Architectures, the system will be created in a number of small applications or called Services, and used to complete certain specific tasks only.</li><li>In addition, in this architecture, each Service will be deployed and run independently</li><li>In this architecture, it is not strange if a system has hundreds or even thousands of independent Services, this is because each Service does have its own task.</li></ul><p><img alt="Microservices Architecture" loading=lazy src=https://i.imgur.com/QHtOgoT.png></p><h2 id=topology-4>Topology<a hidden class=anchor aria-hidden=true href=#topology-4>#</a></h2><ul><li>Usually in Microservices Architecture, each Service will run independently and have its own database, not sharing the database with other Services.</li><li>Usually, each Service will not be exposed openly to users, but users will go through the API Gateway, which is an application that acts as a gateway to receive requests and forward them to the intended Service.</li><li>Because each Service has its own tasks, it is not uncommon for the databases used to be different, this is because usually the Service will use a database that is in accordance with the tasks that must be done.</li></ul><h2 id=bounded-context>Bounded Context<a hidden class=anchor aria-hidden=true href=#bounded-context>#</a></h2><ul><li>As previously explained, each Service will have and manage its own database.</li><li>This means that the database and table can only be accessed by the Service</li><li>For example, when we have a Service that is used to manage Seller data, then the Seller Service can only manage the Seller data.</li><li>This concept is called Bounded Context, which was introduced by Eric Evans in the Domain-Driven Design book.</li></ul><p><img alt="Bounded Context" loading=lazy src=https://i.imgur.com/4e1CUGn.png></p><h2 id=communication-between-services>Communication Between Services<a hidden class=anchor aria-hidden=true href=#communication-between-services>#</a></h2><ul><li>With Bounded Context, it means that no one can access the Seller database directly from another Service except the Seller Service.</li><li>If there is another Service that requires Seller data, then the other Service must request Seller data from Seller Service, using a predetermined communication method, for example RESTful API (Client-Server Architecture).</li></ul><h2 id=example-6>Example<a hidden class=anchor aria-hidden=true href=#example-6>#</a></h2><ul><li>On the online store web page, we want to display detailed Product data.</li><li>However, on the Product detail data page, in addition to Product information, we also want to display data from the Seller who sells the Product.</li><li>In this case, we can take Product data to Product Service, then Product Service requests Seller data from Seller Service.</li></ul><p><img alt="Example of Microservices Architecture" loading=lazy src=https://i.imgur.com/8wFM0gc.png></p><h2 id=supporters>Supporters<a hidden class=anchor aria-hidden=true href=#supporters>#</a></h2><ul><li><p>To use Microservices Architecture usually does not only involve the programmer team.</p></li><li><p>There are many things that must be changed such as infrastructure and product/business teams.</p></li><li><p>This is because usually in Microservice Architecture, the division of Services will be done based on the business domain, so it is not easy to create small applications.</p></li><li><p>In some cases, errors in creating Service types can complicate the development team, therefore Domain Experts or those who are experts in their fields in terms of business are needed.</p></li></ul><h2 id=considerations-7>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-7>#</a></h2><ul><li>Microservice Architecture is usually used in large companies with large development teams, this is because this architecture requires a lot of work other than application creation, such as infrastructure, automation, deployment and others.</li><li>Do not use this architecture if the team is still small, we can start with Monolith Architecture and Layered Architecture, if it is time to need rapid team scaling, we can consider using Microservices Architecture.</li></ul><h1 id=event-driven-architecture>Event-Driven Architecture<a hidden class=anchor aria-hidden=true href=#event-driven-architecture>#</a></h1><h2 id=microservices-architecture-problems>Microservices Architecture Problems<a hidden class=anchor aria-hidden=true href=#microservices-architecture-problems>#</a></h2><ul><li>With the increasing use of Microservices Architecture, finally there is one problem that is often experienced by users of this architecture, namely the dependency between Services.</li><li>For example, in the previous case, when the Seller Service has a problem, for example it dies, then we cannot see the Product data, this is because the Product Service needs to call the Seller Service when it wants to display Product data.</li></ul><h2 id=event-driven-architecture-1>Event-Driven Architecture<a hidden class=anchor aria-hidden=true href=#event-driven-architecture-1>#</a></h2><ul><li>Event-Driven Architecture is an architecture that uses Async Process to communicate with each other between Services.</li><li>Usually, in this architecture, the Service will send every data change that occurs in the Service to an application called Message Broker in the form of Event data.</li><li>We call the sender of Event data Producer/Publisher.</li><li>The service that needs its Event data will take the data from the Message Broker.</li><li>We call the recipient of Event data Consumer/Listener.</li></ul><p><img alt="Event-Driven Architecture" loading=lazy src=https://i.imgur.com/KFTW5Ec.png></p><h2 id=duplicate-data>Duplicate Data<a hidden class=anchor aria-hidden=true href=#duplicate-data>#</a></h2><ul><li>As we already know, in Microservices Architecture there is a Bounded Context rule, where data can only be accessed by the Service itself.</li><li>In the case of Event-Driven Architecture, because we will not call Sync to Other Services (such as using API Call), then usually the Service will consume event data and duplicate the data needed in the Service database.</li><li>In the previous case, for example, the Product Service will consume Seller Event data, then save the Seller data to the Product database as duplicate data.</li></ul><p><img alt="Event-Driven Architecture Example" loading=lazy src=https://i.imgur.com/fIO65AG.png></p><h2 id=considerations-8>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-8>#</a></h2><ul><li>Event-Driven Architecture is currently widely used, because of the problems that occur in Microservices Architecture, but it should be noted, there are also consequences that occur when we use Async Process.</li><li>In the previous case, we must ensure that the Seller Event data is received properly by the Product Service, if it fails automatically the Seller data will not be in the Product database.</li><li>Async Process will also cause the process to be delayed, therefore sometimes users do not receive results in real time, because the Async Process has not finished</li><li>When a problem occurs in the Async Process, searching for problems is more difficult than the Sync Process in the Microservices architecture.</li></ul><h1 id=pipeline-architecture>Pipeline Architecture<a hidden class=anchor aria-hidden=true href=#pipeline-architecture>#</a></h1><ul><li>Pipeline Architecture is an architecture that is closely related to Data Stream.</li><li>In some cases, sometimes we encounter data sources that come in non-stop, for example user activity log data.</li><li>In cases like this, storing data in a database will be very difficult to process, because incoming data is usually in large quantities and continuously.</li><li>Pipeline Architecture is an architecture where we utilize Message Queue like Message Broker as a place for data flow, and we can focus on creating Filters to process the data.</li></ul><p><img alt="Pipeline Architecture" loading=lazy src=https://i.imgur.com/C4PQC3i.png></p><h2 id=topology-5>Topology<a hidden class=anchor aria-hidden=true href=#topology-5>#</a></h2><ul><li>In Pipeline Architecture, the main focus is the Filter process for messages.</li><li>There is no rule for the Filter process whether it must be in the same or different applications, so there is no right or wrong.</li><li>Filters are usually processes that are carried out from receiving input data, processing data, and ending with producing output data.</li></ul><h2 id=cloud-function>Cloud Function<a hidden class=anchor aria-hidden=true href=#cloud-function>#</a></h2><ul><li>This Pipeline Architecture is now very popular in Cloud Providers such as Google Cloud or Amazon Web Service.</li><li>These Cloud Providers now have features for Cloud Function, which can be used as Filters in Pipeline Architecture.</li><li>One of the advantages of using Cloud Function, we only need to pay when the Filter processes data.</li></ul><h2 id=data-pipeline>Data Pipeline<a hidden class=anchor aria-hidden=true href=#data-pipeline>#</a></h2><ul><li>Pipeline Architecture is also often used in data processing, or often known as Data Pipeline.</li><li>In Data Pipeline, there is usually a Source (data source), Destination (final destination of data), and also Processing (data processing).</li></ul><p><img alt="Data Pipeline" loading=lazy src=https://i.imgur.com/DnpaHg3.png></p><h2 id=example-7>Example<a hidden class=anchor aria-hidden=true href=#example-7>#</a></h2><ul><li>We want to create a report on the number of daily visitors to our website, where in the report, we can see the number of visitors based on the country of the visitor</li><li>In this case we can use Pipeline Architecture.</li><li>Starting from every visit data to our website, we will send it as an event to the Message Broker, then we will create a filter, from a filter to detect the IP address, a filter to get the country based on the IP, and a filter to group by country.</li></ul><p><img alt="Example of Pipeline Architecture" loading=lazy src=https://i.imgur.com/1ofWLgu.png></p><h2 id=considerations-9>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-9>#</a></h2><ul><li>Pipeline Architecture is a very suitable architecture when we want to do very long and gradual processing.</li><li>Pipeline Architecture can take a very long time to process, depending on how long the Filter is, therefore it is not suitable for doing work that requires real time.</li></ul><h1 id=space-based-architecture>Space-Based Architecture<a hidden class=anchor aria-hidden=true href=#space-based-architecture>#</a></h1><h2 id=triangle-shaped>Triangle-Shaped<a hidden class=anchor aria-hidden=true href=#triangle-shaped>#</a></h2><ul><li>In certain cases, there are types of applications that usually have unexpected visitor traffic, such as flash sale websites, ticket sales or bidding.</li><li>The architectures that we discussed earlier, we can actually use to create these types of applications, but in certain cases, sometimes we end up getting triangle-shaped problems.</li></ul><p><img alt=Triangle-Shaped loading=lazy src=https://i.imgur.com/tyOQZcQ.png></p><h2 id=triangle-shaped-topology>Triangle-Shaped Topology<a hidden class=anchor aria-hidden=true href=#triangle-shaped-topology>#</a></h2><ul><li>Triangle-Shaped Topology is a condition where we do scalability by increasing the number of applications when there is a slowdown in our system.</li><li>In cases when we create a website, increasing the number of web servers is usually very easy, because it only provides a website user interface, then usually the slowdown will move to the Backend server, for example in the RESTful API.</li><li>Next, we will usually add the number of RESTful API servers, but not as many as Web Servers, because usually the application is heavier and requires more resources, then the slowness will move to the Database.</li><li>In cases like this, adding servers to the database is not easy, not as flexible as Web Servers and RESTful APIs, because the database is a stateful application (storing data).</li></ul><h2 id=space-based-architecture-1>Space-Based Architecture<a hidden class=anchor aria-hidden=true href=#space-based-architecture-1>#</a></h2><ul><li><p>Space-Based Architecture is an architecture specifically designed for cases like this, where we need good scalability and performance for the application.</p></li><li><p>Space-Based Architecture solves this problem by removing the database from the application transaction process and replacing it with shared memory (Data Grid).</p></li><li><p>High Scalability is achieved by connecting all applications to shared memory (Data Grid) synchronously, and asynchronously the data in shared memory will be synced to the database,</p></li></ul><p><img alt="Space-Based Architecture" loading=lazy src=https://i.imgur.com/vA0NYSq.png></p><h2 id=topology-6>Topology<a hidden class=anchor aria-hidden=true href=#topology-6>#</a></h2><ul><li>In Spaced-Based Architecture, the application we create is called a Processing Unit.</li><li>In the Processing Unit, there is our application logic and also contains the In Memory Data Grid which is used as a replacement for the Database.</li><li>Usually there is a Data Replication Engine which is used to synchronize all data in the In Memory Data Grid for all Processing units assisted by the Data Grid Cluster.</li><li>If we want, we can async save the changes that occur in the In Memory Data Grid to the Database.</li></ul><h2 id=data-grid-example>Data Grid Example<a hidden class=anchor aria-hidden=true href=#data-grid-example>#</a></h2><ul><li>Usually Data Grid does not need to be created manually by application developers, just like the Database, we can use the Data Grid application that is already available, for example.</li><li>Hazelcast.</li><li>Apache Ignite.</li><li>Oracle Coherence.</li><li>And others.</li></ul><h2 id=considerations-10>Considerations<a hidden class=anchor aria-hidden=true href=#considerations-10>#</a></h2><ul><li>Spaced-Based Architecture is a very complex solution to achieve excellent scalability.</li><li>However, although this solution is very good, sometimes this solution is not the best, we must see many considerations when using this architecture.</li><li>For example, if our data is too large, it will be difficult to use this architecture, because all data must be moved to memory, which certainly requires a very large cost.</li><li>Because of the complexity and high cost of this solution, we must also consider the costs that must be incurred to use this architecture.</li></ul><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><ul><li>Software Architecture Patterns are not a rigid solution where we have to choose one.</li><li>We can combine several Patterns that suit our needs.</li><li>For example, we can combine Microservices and Event-Driven, or Monolith with Layered, Microservices with Layered, and so on.</li></ul><h2 id=other-software-architecture-patterns>Other Software Architecture Patterns<a hidden class=anchor aria-hidden=true href=#other-software-architecture-patterns>#</a></h2><ul><li>This class does not discuss all existing Software Architecture Patterns, only those that are often used.</li><li>Technology, especially in Software Design, is always evolving over time, in the early 2000s not many people used Microservices, but now almost all large companies use them.</li><li>There are still many patterns that have not been discussed, and can be studied independently, such as: Onion Architecture, Screaming Architecture, Event-Bus Architecture, and many others.</li></ul><hr><p>Source:<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Ix09qfew6oA?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wewnumam.github.io/articles/welcome-to-artificial-intelligence/><span class=title>« Prev</span><br><span>Welcome to Artificial Intelligence</span>
</a><a class=next href=https://wewnumam.github.io/articles/learn-from-free-college-cs-courses/><span class=title>Next »</span><br><span>Learn From Free College Cs Courses</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on x" href="https://x.com/intent/tweet/?text=Software%20Architecture%20Patterns&amp;url=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f&amp;title=Software%20Architecture%20Patterns&amp;summary=Software%20Architecture%20Patterns&amp;source=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f&title=Software%20Architecture%20Patterns"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on whatsapp" href="https://api.whatsapp.com/send?text=Software%20Architecture%20Patterns%20-%20https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on telegram" href="https://telegram.me/share/url?text=Software%20Architecture%20Patterns&amp;url=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on ycombinator" href="https://news.ycombinator.com/submitlink?t=Software%20Architecture%20Patterns&u=https%3a%2f%2fwewnumam.github.io%2farticles%2fsoftware-architecture-patterns%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wewnumam.github.io/>Ahmad Adillaumam</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>