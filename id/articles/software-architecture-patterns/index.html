<!doctype html><html lang=id dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Patterns | Ahmad Adillaumam</title><meta name=keywords content><meta name=description content="Pendahuluan

Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang.
Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat.
Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan.
Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan.

Software Architecture Patterns

Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak.
Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak.
Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak.

Tujuan Architecture Patterns

Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain.
Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya.

Architecture Classification

Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute.
Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi.
Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi.

Monolithic Architectures

Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture.
Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan.
Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan.


Distributed Architecture

Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi.
Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service.
Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal

"><meta name=author content="Ahmad Adillaumam"><link rel=canonical href=https://wewnumam.github.io/id/articles/software-architecture-patterns/><meta name=google-site-verification content="G-2KZ9LNNSKF"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://wewnumam.github.io/favicon.png><link rel=apple-touch-icon href=https://wewnumam.github.io/favicon.png><link rel=mask-icon href=https://wewnumam.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wewnumam.github.io/articles/software-architecture-patterns/><link rel=alternate hreflang=id href=https://wewnumam.github.io/id/articles/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2KZ9LNNSKF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2KZ9LNNSKF")}</script><meta property="og:url" content="https://wewnumam.github.io/id/articles/software-architecture-patterns/"><meta property="og:site_name" content="Ahmad Adillaumam"><meta property="og:title" content="Software Architecture Patterns"><meta property="og:description" content="Pendahuluan Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang. Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat. Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan. Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan. Software Architecture Patterns Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak. Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak. Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak. Tujuan Architecture Patterns Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain. Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya. Architecture Classification Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute. Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi. Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi. Monolithic Architectures Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture. Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan. Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan. Distributed Architecture Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi. Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service. Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal "><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2025-04-29T20:27:22+07:00"><meta property="article:modified_time" content="2025-04-29T20:27:22+07:00"><meta property="og:image" content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:title content="Software Architecture Patterns"><meta name=twitter:description content="Pendahuluan

Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang.
Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat.
Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan.
Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan.

Software Architecture Patterns

Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak.
Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak.
Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak.

Tujuan Architecture Patterns

Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain.
Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya.

Architecture Classification

Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute.
Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi.
Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi.

Monolithic Architectures

Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture.
Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan.
Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan.


Distributed Architecture

Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi.
Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service.
Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal

"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://wewnumam.github.io/id/articles/"},{"@type":"ListItem","position":2,"name":"Software Architecture Patterns","item":"https://wewnumam.github.io/id/articles/software-architecture-patterns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Software Architecture Patterns","name":"Software Architecture Patterns","description":"Pendahuluan Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang. Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat. Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan. Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan. Software Architecture Patterns Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak. Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak. Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak. Tujuan Architecture Patterns Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain. Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya. Architecture Classification Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute. Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi. Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi. Monolithic Architectures Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture. Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan. Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan. Distributed Architecture Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi. Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service. Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal ","keywords":[],"articleBody":"Pendahuluan Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang. Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat. Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan. Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan. Software Architecture Patterns Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak. Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak. Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak. Tujuan Architecture Patterns Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain. Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya. Architecture Classification Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute. Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi. Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi. Monolithic Architectures Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture. Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan. Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan. Distributed Architecture Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi. Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service. Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal Pilih yang Mana? Pada saat pembuatan aplikasi, kadang kita bingung menentukan harus menggunakan arsitektur Monolithic atau Distributed? Jika aplikasi yang akan kita buat sederhana atau masih belum jelas secara business requirement, sangat disarankan menggunakan Monolithic, karena mudah untuk dibuat. Namun jika aplikasi yang akan kita buat sudah sangat jelas, dan juga memang membutuhkan, scalability yang baik, termasuk fault tolerance yang baik, maka kita bisa gunakan arsitektur Distributed. Architecture Partitioning Selain dilihat secara klasifikasi monolithic atau distributed, software architecture juga bisa dilihat secara struktur partisinya. Software architecture baik itu monolithic atau distributed, secara partisi bisa dibagi berdasarkan teknis atau domain. Partisi secara struktur bisa digunakan di monolithic atau distributed. Technical Partitioning Arsitektur Technical Partitioning membagi komponen-komponen dalam system atau aplikasi secara teknis. Contoh arsitektur klasik yang sering digunakan adalah Layered (N-Tier) Architecture. Dalam Technical Partitioning, komponen dalam system dikelompokan secara teknis, misal : Presentation Layer merupakan komponen yang menangani user interface. Business Layer, merupakan komponen yang menangani logika dan aturan bisnis. Persistence Layer, merupakan komponen yang menangani interaksi dengan sistem basis data. Database Layer, merupakan komponen untuk menyimpan data. Domain Partitioning Berbeda dengan Technical Partitioning, dalam Domain Partitioning, pembagian struktur komponen dalam system dikelompokan berdasarkan Domain/Fitur/ Departemen secara bisnisnya. Artinya semua Technical Partitioning seperti Presentation, Business Logic, Persistence, digabung dalam per domain system. Partisi system berdasarkan Domain, populer sejak dikenalkan dalam buku berjudul “Domain Driven Design” karya Eric Evans. Pilih yang Mana? Technical ataupun Domain Partitioning memiliki kelebihan dan kekurangan, namun secara pribadi saya rekomendasikan gunakan: Technical Partitioning ketika aplikasi yang akan dibuat sederhana dan tidak kompleks, Selain itu ketika jumlah anggota tim pengembang tidak terlalu banyak. Domain Partitioning ketika aplikasi yang akan dibuat kompleks dan fitur aplikasi sangat banyak. Dan sangat cocok ketika anggota tim pengembang banyak pembagian tim berdasarkan jenis domainnya. Layered Architecture Layered Architecture dikenal juga dengan N -Tier Architecture. Arsitektur ini adalah salah satu standard arsitektur untuk kebanyakan aplikasi, di mana aplikasi dibagi secara teknis. Karena arsitektur ini sangat banyak diketahui oleh pengembang perangkat lunak, hal ini menjadikan arsitektur ini menjadi salah satu pilihan yang banyak digunakan. Komponen Layered Architecture Layered Architecture dibagi secara teknis, oleh karena itu komponen-komponen dalam Layered Architecture sama dengan Technical Partition. Rata-rata banyak yang membagi menjadi 4 layer, Presentation Layer, Business Layer, Persistence Layer dan Database Layer. Namun tidak menutup kemungkinan bisa lebih banyak layer ketika aplikasi sangat kompleks. Tugas Tiap Layer Setiap layer di Layered Architecture memiliki tugas masing-masing. Presentation Layer bertanggung jawab menangani semua user interface. Business Layer bertanggung jawab mengeksekusi permintaan logika atau aturan bisnis yang sesuai permintaan. Persistence Layer bertanggung jawab untuk berinteraksi dengan database untuk melakukan pengolahan data di database. Database Layer bertanggung jawab untuk menyimpan semua data aplikasi. Layers of Isolation Dalam Layered Architecture, tiap Layer akan terisolasi, dan arah komunikasi hanya dilakukan dengan layer di bawah atau di atasnya. Artinya, misal ketika Presentation Layer ingin mengambil data Product, Presentation Layer akan mengirim request ke Business Layer, lalu akan mengambil data ke Persistence Layer dan baru masuk ke Database Layer. Tidak direkomendasikan untuk langsung mengakses dari Presentation Layer langsung ke Database Layer. Contoh Setelah tahu cara kerja Layered Architecture, maka kita bisa dengan mudah menggambarkan alur yang harus dibuat ketika membuat aplikasi. Misal kita ingin menampilkan halaman Product, namun di dalam halaman Product kita juga ingin menampilkan data Seller-nya. Maka kita bisa buat alur aplikasi seperti pada diagram selanjutnya. Pertimbangan Layered Architecture adalah salah satu arsitektur yang banyak dimengerti dan digunakan. Gunakan Layered Architecture jika kita masih bingung ingin menggunakan arsitektur apa, karena ini adalah arsitektur yang bagus untuk memulai aplikasi. Namun jangan gunakan Layered Architecture ketika pembagian tim di perusahaan sudah berdasarkan domain, lebih cocok menggunakan Distributed Architecture yang akan kita bahas di materi-materi selanjutnya. Model-View-Controller Architecture Model View Controller (MVC) Architecture merupakan salah satu arsitektur yang sangat populer ketika membuat Web. MVC mirip dengan Layered Architecture, hanya saja layer-nya berbeda. Dalam MVC pusat interaksi antar layer biasanya dilakukan oleh Controller. Tugas Tiap Layer Dalam MVC, setiap layer memiliki tugas masing-masing. Controller adalah layer yang bertanggung jawab untu k menerima request dan mengeksekusi logika dan aturan bisnis yang terjadi di aplikasi. Model merupakan layer yang bertanggung jawab sebagai representasi data di database dan juga berinteraksi ke database. View merupakan layer yang berisi template untuk tampilan halaman web. Database merupakan layer untuk menyimpan data aplikasi. Contoh Misal kita memiliki web di mana terdapat satu halaman web yang perlu untuk menampilkan data wishlist. Pada halaman Itu, selain data wishlist, kita juga harus menampilkan detail product yang terdapat di wishlist tersebut.\nPertimbangan MVC adalah pilihan utama ketika kita ingin membuat aplikasi Web. Banyak sekali web framework yang sudah secara otomatis menggunakan arsitektur ini seperti Laravel, NestJS, Rails, Django, dan lain-lain. Namun ketika kita membuat RESTful API misalnya, kita tidak wajib mengikuti aturan MVC, karena biasanya kita tidak memerlukan layer View. Pada kasus seperti ini, kita bisa saja menggabungkan arsitektur MVC ini dengan Layered Architecture. Hexagonal Architecture Salah satu masalah ketika menggunakan Layered Architecture adalah, perubahan jenis teknologi yang digunakan, akan menyulitkan pengembangan. Contoh ketika kita harus mengganti teknologi database yang digunakan, secara otomatis akan terjadi perombakan besar-besaran pada kode program Persistence Layer dan Database Layer, yang mungkin bisa menyebabkan perombakan juga pada Business Layer. Hexagonal Architecture merupakan arsitektur yang dikembangkan dari Layered Architecture, namun lebih baik ketika menangani perubahan teknologi yang terjadi. Hexagonal Architecture juga dikenal dengan Port \u0026 Adapter Architecture Port dan Adapter Hexagonal Architecture sebenarnya dikenalkan dengan nama Pert \u0026 Adapter Architecture, namun saat ini lebih populer dengan nama Hexagonal Architecture. Port merupakan technology-agnostic yang merupakan sebuah OOP (Object Oriented Programming) Interface, yang digunakan oleh kode aplikasi untuk berkomunikasi dengan pihak lain. Adapter merupakan bagian yang berinteraksi langsung melalui Port, dan menggunakan teknologi yang sudah ditentukan. Application Layer Dalam Hexagonal Architecture, Application Layer akan berisi logika dan aturan bisnis, di mana kode yang dibuat akan berinteraksi hanya dengan Port, tanpa tahu Adapter yang digunakan. Hal ini agar tercapainya technology agnostic, sehingga ketika Adapter diubah, Application Layer tidak perlu berubah. Selain itu, di dalam Application Layer, terdapat Domain Layer, yang berisikan representasi data domain aplikasi. Bagian Driving, biasanya disebut User Interface/Transport Layer/Gateway, yaitu sumber request masuk ke aplikasi. Bagian Driven, biasanya disebut Infrastructure/Data Source/External Interfaces, yaitu target data keluar dari aplikasi. Clean Architecture Saat ini, terkenal juga arsitektur dengan nama Clean Architecture. Jangan bingung jika harus memilih Hexagonal Architecture atau Clean Architecture. Sebenarnya Clean Architecture tidak berbeda jauh dengan Hexagonal Architecture, bahkan penulis buku Clean Architecture pun memang sudah menjelaskan bahwa salah satu referensi Clean Architecture adalah dari Hexagonal Architecture. Contoh Misal kita memiliki aplikasi Web toko online, di mana kita akan membuat halaman pembayaran. di mana saat melakukan data pembayaran selain disimpan di database, akan dikirim ke Payment Gateway. Pertimbangan Hexagonal Architecture merupakan salah satu arsitektur yang bagus digunakan ketika kita akan membuat aplikasi yang kompleks dan agar aplikasinya technology agnostic sehingga mudah diganti-ganti. Namun pengembangan Hexagonal Architecture tidaklah semudah Layered Architecture, sehingga jika pengembang belum familiar dengan Hexagonal Architecture, maka bisa terkendala ketika proses pengembangan. Microkernel Architecture Microkernel Architecture sangat flexible dan extensible, sehingga pengembang bisa dengan mudah menambah fitur pada aplikasi dalam bentuk extension atau plug-in, tanpa takut menggangu fungsionalitas dari aplikasinya itu sendiri. Oleh karena itu, Microkernel Architecture juga sering disebut sebagai Plug-in Architecture. Microkernel Architecture sangat banyak digunakan pada aplikasi berbasis desktop biasanya, contoh seperti Visual Studio, Eclipse, dan lain-lain, di mana ada banyak sekali extension atau plug-in yang tersedia untuk aplikasi tersebut. Topology Dalam Microkernel Architecture, hanya terdapat dua layer, Core System dan juga Plugin Modules. Logic aplikasi di Microkernel Architecture biasanya di tempatkan di Plugin, maka dari itu arsitektur ini terlihat seperti Hexagonal Architecture, tetapi sebenarnya bukan. Dalam Hexagonal Architectwe, logic aplikasi ditempatkan di aplikasi, sedangkan di Microkernel Architecture, detail logic aplikasi berada di tiap Plugin masing-masing. Pertimbangan Microkernel Architecture sangat populer digunakan ketika membuat aplikasi Desktop berbasis plugin, seperti Visual Studio, Eclipse, IntelliJ IDEA Ghkan seperti Browser. Gunakan Microkernel Architecture jika memang kita ingin membuat aplikasi yang berbasis Plugin. Salah satu keunggulan Microkernel Architecture adalah, orang lain bisa berkontribusi membuat Plugin untuk aplikasi kita. Client-Server Architecture Client-Server Architecture adalah salah satu Distributed System Architecture yang banyak dikenal dan digunakan. Arsitektur ini sangat sederhana, di mana terdapat aplikasi Client dan Server yang saling berinteraksi. Biasanya komunikasi antara Client dan Server menggunakan jaringan TCP/IP, walaupun tidak tertutup kemungkinan menggunakan jaringan lain seperti UDP. Topology Client adalah aplikasi yang digunakan oleh pengguna dan berinteraksi langsung dengan pengguna, Biasanya aplikasi Client adalah aplikasi yang berbasis user interface, baik itu berupa Web, Desktop atau bisa saja berbasis Terminal, Client akan mengirim semua request yang diminta oleh pengguna ke aplikasi Server Server adalah inti dari aplikasi, di mana semua logika dan aturan bisnis dilakukan di Server, Server akan menjalankan perintah yang diminta oleh Client, dan mengembalikan data yang diminta ke Client Keuntungan menggunakan Client-Server Architecture adalah, kita bisa menjalankan banyak aplikasi jenis Client hanya dengan menggunakan satu aplikasi Server Contoh Client-Server Architecture adalah arsitektur yang saat ini sangat banyak digunakan, bahkan mungkin secara tidak sadar, kita sudah menggunakan arsitektur ini. Ketika kita membuat aplikasi Mobile lalu terkoneksi ke RESTful API, sebenarnya itu adalah Client-Server Architecture. Pertimbangan Saat kita ingin membuat aplikasi, yang ingin memisahkan aplikasi Client, atau bahkah membuat banyak jenis aplikasi Client, maka arsitektur Client-Server sangat cocok digunakan Namun jika kita ingin membuat aplikasi yang standalone, tidak butuh menyimpan data di Server, maka kita tidak butuh membuat aplikasi Client-Server, contoh seperti aplikasi editor untuk Photo, Video dan sejenisnya Master-Slave Architecture Master-Slave Architecture merupakan arsitektur di mana aplikasi bisa mendistribusikan semua pekerjaannya ke aplikasi lain. Aplikasi yang memerintah sza aplikasi dinamakan Master, dan aplikasi yang menerima perintah dinamakan Slave. Sama seperti Client-Server Architecture, biasanya komunikasi Master dan Slave menggunakan jaringan TCP/IP. Topology Biasanya, semua request ke aplikasi akan lewat aplikasi Master. Semua pekerjaan yang diterima oleh Master, biasanya akan didistribusikan ke aplikasi Slave. Dengan begitu, pekerjaan bisa lebih cepat karena bisa dikerjakan oleh banyak aplikasi Slave. Pada diagram, kita hanya membuat 3 aplikasi Slave, namun kenyataanya, tidak ada batasan jumlah aplikasi Slave. Fault Tolerance Salah satu keunggukan Master-Slave Architecture adalah, Fault Torelance, di mana ketika misal terjadi kesalahan yang menyebabkan salah satu aplikasi Slave mati, maka pekerjaan masih bisa dikerjaan oleh aplikasi Slave Iain. Begitu juga ketika terjadi masalah yang menyebabkan aplikasi Master mati, maka secara otomatis salah satu Slave akan dipromosikan menjadi Master baru. Master-Master Architecture Salah satu kekurangan Master-Slave Architecture adaIah, semua request harus melewati aplikasi Master, sehingga ketika terjadi kelambatan di aplikasi Master, secara otomatis semua pengguna akan merasakan dampaknya, padahal mungkin aplikasi Slave tidak lambat. Pada kasus seperti itu, terdapat juga Master-Master Architecture, di mana ini adalah improvement dari Master-Slave Architecture. Yang membedakan Master-Master Architecture adalah, semua aplikasi bisa berjalan sebagai Master, sehingga bisa menerima request dari pengguna secara mandiri Dan karena semua aplikasi adalah Master, tiap aplikasi bisa saja mengirim request ke aplikasi Iain, ketika misal aplikasi sudah terlalu banyak menangani request dari pengguna. Replication Yang perlu diingat dalam Master-Slave/Master-Master Architecture, biasanya data di aplikasi selalu di replikasi/duplikasi ke semua Slave/Master. Hal ini agar data selalu sama, sehingga pekerjaan yang dikerjakan oleh semua aplikasi Slave/Master akan selalu konsisten. Contoh Master-Slave/Master-Master Architecture jangan digunakan ketika membuat aplikasi sistem informasi, arsitektur ini rata-rata sering digunakan ketika kita membuat aplikasi stateful! (menyimpan data) seperti sistem basis data. Hampir kebanyakan aplikasi sistem basis data seperti MySQL, PostgreSQL, MongoDB mengimplementasikan arsitektur Master-Slave Architecture Atau seperti aplikasi sistem basis data Elasticsearch dan Cassandra, yang menggunakan Master-Master Architecture. Pertimbangan Gunakan arsitektur Master-Slave/Master-Master ketika kita ingin membuat aplikasi yang stateful! (menyimpan data) Jika kita membuat aplikasi yang stateless (tidak menyimpan data), maka disarankan tidak menggunakan arsitektur ini. Peer-to-Peer Architecture Peer-to-Peer Architecture merupakan arsitektur yang hampir mirip dengan Client-Server Architecture. Hanya saja, dalam Peer-to-Peer, semua aplikasi bisa menjadi Client dan juga Server secara berbarengan. Biasanya logika aplikasi akan terpusat di aplikasi Server, pada Peer-to-Peer, logika aplikasi tidak terpusat di satu aplikasi, semua aplikasi bisa menjadi Server sekaligus Client. Topology Dalam Peer-to-Peer Architecture seakan terlihat sederhana, namun sebenarnya arsitektur ini sangat kompleks. Setiap Peer bisa menjadi Client yang melakukan request ke Peer lain, atau bahkan menjadi Server pada saat yang bersamaan dengan mengirim response ke Peer lain. Oleh karena itu pembuatan aplikasi Peer-to-Peer Architecture sangat kompleks karena setiap Peer harus tahu ketika terdapat Peer baru, karena pada kenyataannya Peer baru bisa datang dan hilang kapan saja. vs Master-Master Architecture Apa bedanya Peer-to-Peer Architecture dan Master-Master Architecture? Pada Peer-to-Peer, tiap Peer bisa menjadi Client ataupun Server. Sedangkan pada Master-Master, tiap Master adalah Server, biasanya Client adalah aplikasi yang terpisah dan terkoneksi ke Master-Master dengan arsitektur Client-Server. Contoh Peer-to-Peer banyak sekali digunakan untuk aplikasi berbagi file seperti Torrent misalnya, di mana setiap orang bisa berbagi file, sekaligus meminta file ke Peer lain di dalam jaringan Torrent-nya. Selain itu, Peer-to-Peer juga sering digunakan dalam Cryptocurrency di mana semua data terdistribusi di semua aplikasi Peer untuk menjaga data tetap aman karena untuk mengubah data, kita harus mengubah seluruh data di semua Peer, dan itu sangat sulit untuk dilakukan. Pertimbangan Peer-to-Peer Architecture mungkin terlihat sangat menarik, namun ini adalah jenis arsitektur yang jarang sekali digunakan, kecuali pada jenis aplikasi yang membutuhkan logika yang tidak terpusat. Peer-to-Peer Architecture juga merupakan arsitektur yang sangan scalable, karena sulit untuk terjadi kegagalan sistem karena semua logic terdistribusi di semua Peer Kekurangannya adalah, karena kita tidak bisa menjadi kualitas resource di tiap Peer, jadi, besar kemungkinan kualitas dan kecepatan aplikasi tidak bisa dijaga dengan baik, terutama jika Peer berjalan di hardware dengan resource yang kurang. Microservices Architecture Microservices Architecture adalah jenis arsitektur yang saat sedang banyak sekali digunakan Oleh banyak orang Namun arsitektur ini bukanlah jenis arsitektur yang sederhana, ini adalah jenis arsitektur yang kompleks. Pada Microservices Architectures, system akan dibuat dalam jumlah aplikasi-aplikasi kecil atau disebut Service, dan digunakan untuk menyelesaikan tugas spesifik tertentu saja. Selain itu pada arsitektur ini, tiap Service akan di deploy dan dijalankan secara mandiri Pada arsitektur ini, tidak aneh jika sebuah system memiliki ratusan bahkan ribuan Service mandiri, hal ini karena tiap Service memang memiliki tugas masing-masing. Topology Biasanya dalam Microservices Architecture, setiap Service akan berjalan secara independent dan memiliki database masing-masing, tidak melakukan sharing database dengan Service lain. Biasanya juga tiap Service tidak akan di expose secara terbuka ke pengguna, melainkan pengguna akan melewati API Gateway, yaitu aplikasi yang bertugas sebagai gerbang untuk menerima request dan meneruskan ke Service yang dituju. Karena tiap Service memiliki tugas masing-masing, maka tidak jarang database yang digunakanpun bisa berbeda-beda, hal ini karena biasanya Service akan menggunakan database yang sesuai dengan tugas yang harus dikerjakan. Bounded Context Seperti yang dijelaskan sebelumnya, bahwa tiap Service akan memiliki dan melakukan manajemen database-nya sendiri. Artinya database dan table tersebut hanya boleh diakses Oleh Service tersebut Contoh misal ketika kita memiliki Service yang digunakan untuk melakukan management data Seller, maka Seller Service yang hanya boleh melakukan management data Seller tersebut. Konsep ini, disebut dengan Bounded Context, yang dikenalkan Oleh Eric Evans pada buku Domain-Driven Design. Komunikasi Antar Service Dengan adanya Bounded Context, artinya tidak ada yang boleh mengakses database Seller secara langsung dari Service lain kecuali Seller Service. Jika ada Service lain yang membutuhkan data Seller, maka Service lain tersebut harus meminta data Seller ke Seller Service, dengan cara komunikasi yang sudah ditentukan, misal RESTful API (Client-Server Architecture). Contoh Pada halaman web toko online, kita ingin menampilkan data detail Product. Namun pada halaman data detail Product, selain informasi Product, kita juga ingin menampilkan data Seller yang menjual Product tersebut. Pada kasus ini, kita bisa mengambil data Product ke Product Service, lalu Product Service meminta data Seller ke Seller Service. Pendukung Untuk menggunakan Microservices Architecture biasanya tidak hanya melibatkan tim programmer. Banyak sekali yang harus diubah seperti infrastructure dan tim product/bisnis. Hal ini karena biasanya dalam Microservice Architecture, pembagian Service akan dilakukan berdasarkan domain bisnis, jadi tidak sederhana membuat aplikasi kecil. Pada beberapa kasus, kesalahan pembuatan jenis Service bisa mempersulit tim pengembang, Oleh karena itu diperlukan orang Domain Expert atau yang sudah ahli di bidangnya secara bisnis. Pertimbangan Microservice Architecture biasanya digunakan di perusahaan yang sudah besar dengan tim pengembang yang banyak, hal ini dikarenakan arsitektur ini menuntut banyak sekali pekerjaan selain pekerjaan membuat aplikasi, seperti infrastruktur, automation, deployment dan Iain-Iain. Jangan gunakan arsitektur ini jika tim masih kecil, kita bisa mulai dengan Monolith Architecture dan Layered Architecture, jika sudah waktunya membutuhkan scaling tim secara cepat, kita baru bisa mempertimbangkan penggunaan Microservices Architecture. Event-Driven Architecture Masalah Microservices Architecture Dengan meningkatnya penggunaan Microservices Architecture, akhirnya terdapat salah satu masalah yang sering dialami pengguna arsitektur tersebut, yaitu ketergantungan antar Service. Contoh pada kasus sebelumnya misalnya, ketika Seller Service bermasalah, misal mati, maka kita tidak bisa melihat data Product, hal ini karena Product Service butuh memanggil Seller Service ketika ingin menampilkan data Product. Event-Driven Architecture Event-Driven Architecture merupakan arsitektur yang menggunakan Async Proses untuk saling berkomunikasi antar Service. Biasanya, pada arsitektur ini, Service akan mengirim setiap perubahan data yang terjadi pada Service tersebut ke aplikasi bernama Message Broker dalam bentuk data Event. Pengirim data Event kita sebut dengan nama Producer/Publisher. Service yang membutuhkan data Event-nya akan mengambil data tersebut pada Message Broker. Penerima data Event kita sebut dengan nama Consumer/Listener. Duplicate Data Seperti yang sudah kita tahu, dalam Microservices Architecture terdapat aturan Bounded Context, di mana data hanya bisa diakses Oleh Service itu sendiri. Pada kasus Event-Driven Architecture, karena kita tidak akan memanggil secara Sync ke Service Lain (seperti menggunakan API Call), maka biasanya Service akan meng-consume event data dan men-duplicate data yang dibutuhkan di database Service itu. Pada kasus sebelumnya, contohnya Product Service akan meng-consume data Seller Event, lalu menyimpan data Seller ke database Product sebagai data duplicate. Pertimbangan Event-Driven Architecture saat ini banyak yang menggunakan, karena permasalahan yang terjadi di Microservices Architecture, namun perlu diperhatikan, ada juga akibat yang terjadi ketika kita menggunakan Async Process. Pada kasus sebelumnya, kita harus memastikan data Seller Event diterima dengan baik Oleh Product Service, jika gagal secara otomatis data Seller tidak akan ada di database Product. Async Process juga akan menyebabkan proses menjadi delay, Oleh karena itu kadang pengguna tidak menerima hasil secara realtime, karena Async Process belum selesai Ketika terjadi masalah pada Async Process, melakukan pencarian masalah lebih sulit dibanding Sync Process pada arsitektur Microservices. Pipeline Architecture Pipeline Architecture adalah arsitektur yang erat kaitannya dengan Data Stream (aliran data). Pada beberapa kasus, kadang kita menemui sumber data yang masuk tanpa henti, misal data log aktivitas pengguna misalnya. Pada kasus seperti ini, menyimpan data di database akan sangat menyulitkan untuk memprosesnya, karena data masuk biasanya dalam jumlah banyak dan terus menerus. Pipeline Architecture adalah arsitektur di mana kita memanfaatkan Message Queue seperti Message Broker sebagai tempat aliran data, dan kita bisa fokus membuat Filter untuk memproses data tersebut. Topology Dalam Pipeline Architecture, fokus utama adalah proses Filter terhadap message. Tidak ada aturan proses Filter apakah harus di dalam aplikasi yang sama atau berbeda, jadi tidak ada benar atau salah. Filter biasanya adalah proses yang dilakukan dari mulai menerima input data, memproses data, dan berakhir dengan menghasilkan output data. Cloud Function Pipeline Architecture ini sekarang sangat populer di Cloud Provider seperti Google Cloud atau Amazon Web Service. Cloud Provider tersebut sekarang memiliki fitur untuk Cloud Function, di mana bisa digunakan sebagai Filter dalam Pipeline Architecture. Salah satu keuntungan menggunakan Cloud Function, kita hanya perlu bayar ketika Filter melakukan pemrosesan data. Data Pipeline Pipeline Architecture juga sering digunakan dalam melakukan pengolahan data, atau sering dikenal dengan nama Data Pipeline. Dalam Data Pipeline, biasanya terdapat Source (sumber data), Destination (tujuan akhir data), dan juga Processing (pengolahan data). Contoh Kita ingin membuat laporan jumlah pengunjung harian website kita, di mana pada laporan tersebut, kita bisa melihat jumlah pengunjung berdasarkan negara pengunjung Pada kasus ini kita bisa menggunakan Pipeline Architecture. Dimulai dari setiap data kunjungan ke website kita, kita akan kirim sebagai event ke Message Broker, lalu kita akan buat filter, dari filter untuk mendeteksi ip address, filter untuk mendapatkan negara berdasarkan ip, dan filter untuk melakukan grouping berdasarkan negara. Pertimbangan Pipeline Architecture merupakan arsitektur yang sangat cocok ketika kita ingin melakukan pemrosesan yang sangat panjang dan bertahap. Pipeline Architecture bisa sangat lama melakukan pemrosesan, tergantung seberapa panjang Filter yang ada, Oleh karena itu tidak cocok untuk melakukan pekerjaan yang butuh waktu realtime. Space-Based Architecture Triangle-Shaped Pada kasus tertentu, ada jenis aplikasi yang biasanya memiliki traffic pengunjung yang tidak terduga, misal seperti website flashsale, penjualan tiket atau bidding. Arsitektur-arsitektur yang sebelumnya kita bahas, sebenarnya bisa kita gunakan untuk membuat jenis aplikasi tersebut, namun pada kasus tertentu, kadang akhirnya kita mendapatkan permasalahan triangle-shaped. Triangle-Shaped Topology Triangle-Shaped Topology adalah kondisi di mana kita melakukan scalability dengan cara menambah jumlah aplikasi ketika terjadi kelambatan di system kita. Pada kasus ketika kita membuat web, untuk menambah jumlah web server biasanya sangat mudah, karena hanya menyediakan website user interface, selanjutnya biasanya kelambatan akan berpindah ke server Backend misal di RESTful API. Selanjutnya biasanya kita akan menambah jumlah server RESTful API, namun tidak akan sebanyak Web Server, karena biasanya aplikasinya lebih berat dan membutuhkan resource lebih besar, selanjutnya kelambatan akan berpindah ke Database. Pada kasus seperti ini, menambah server di database bukanlah hal yang mudah, tidak sefleksibel Web Server dan RESTful API, karena database adalah aplikasi stateful (menyimpan data). Space-Based Architecture Space-Based Architecture merupakan arsitektur yang di desain khusus untuk kasus seperti ini, di mana kita butuh scalability dan performa yang baik untuk aplikasi. Space-Based Architecture menyelesaikan masalah ini, dengan cara menghapus database dari proses transaksi aplikasi, dan diganti dengan shared-memory (Data Grid). High Scalability dicapai dengan cara semua aplikasi terkoneksi ke shared-memory (Data Grid) secara synchronous, dan secara asynchronous data di shared-memory akan di sync ke database, Topology Dalam Spaced-Based Architecture, aplikasi yang kita buat disebut dengan Processing Unit. Dalam Processing Unit, terdapat logic aplikasi kita dan juga berisi In Memory Data Grid yang digunakan sebagai pengganti Database. Biasanya terdapat Data Replication Engine yang digunakan untuk melakukan sinkronisasi seluruh data di In Memory Data Grid untuk semua Processing unit dengan dibantu Oleh Data Grid Cluster. Jika kita mau, kita bisa secara async menyimpan perubahan yang terjadi di In Memory Data Grid ke Database. Contoh Data Grid Biasanya Data Grid tidak perlu dibuat secara manual Oleh pengembang aplikasi, sama seperti Database, kita bisa menggunakan aplikasi Data Grid yang sudah tersedia, contohnya. Hazelcast. Apache Ignite. Oracle Coherence. Dan lain-lain. Pertimbangan Spaced-Based Architecture merupakan solusi yang sangat kompleks untuk mencapai scalability yang sangat baik. Namun walaupun solusi ini sangat baik, tapi kadang solusi ini bukan yang terbaik, kita harus melihat banyak pertimbangan ketika menggunakan arsitektur ini. Contoh jika data kita terlalu besar, maka akan sulit menggunakan arsitektur ini, karena seluruh data harus dipindahkan ke memory, yang pasti butuh biaya yang sangat besar. Karena kompleksitas dan mahalnya solusi ini, kita juga harus mempertimbangkan biaya yang harus dikeluarkan untuk menggunakan arsitektur ini. Penutup Software Architecture Patterns bukanlah solusi yang saklek di mana kita harus memilih salah satunya. Kita bisa melakukan kombinasi beberapa Patterns yang memang sesuai dengan kebutuhan kita. Misal kita bisa kombinasikan Microservices dan Event-Driven, atau Monolith dengan Layered, Microservices dengan Layered, dan lain-lain. Software Architecture Patterns Lainnya Kelas ini tidak membahas semua Software Architecture Patterns yang ada, hanya membahas yang sering digunakan. Teknologi khususnya pada Software Design selalu berkembang dari waktu ke waktu, awal tahun 2000 belum banyak yang menggunakan Microservices, namun sekarang hampir semua perusahaan besar menggunakannya. Masih banyak juga patterns yang belum dibahas, dan bisa dipelajari secara mandiri, seperti: Onion Architecture, Screaming Architecture, Event-Bus Architecture, dan masih banyak yang lainnya. Sumber: ","wordCount":"4143","inLanguage":"id","image":"https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph","datePublished":"2025-04-29T20:27:22+07:00","dateModified":"2025-04-29T20:27:22+07:00","author":{"@type":"Person","name":"Ahmad Adillaumam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wewnumam.github.io/id/articles/software-architecture-patterns/"},"publisher":{"@type":"Organization","name":"Ahmad Adillaumam","logo":{"@type":"ImageObject","url":"https://wewnumam.github.io/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wewnumam.github.io/id/ accesskey=h title="Ahmad Adillaumam (Alt + H)"><img src=https://wewnumam.github.io/favicon.png alt aria-label=logo height=35>Ahmad Adillaumam</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wewnumam.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://wewnumam.github.io/id/archives/ title=Arsip><span>Arsip</span></a></li><li><a href=https://wewnumam.github.io/id/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://wewnumam.github.io/id/search/ title="Telusuri (Alt + /)" accesskey=/><span>Telusuri</span></a></li><li><a href=https://wewnumam.github.io/id/about/ title="Tentang Saya"><span>Tentang Saya</span></a></li><li><a href=https://github.com/wewnumam/gtstmm-gamedev-roadmap title="Gamedev Roadmap"><span>Gamedev Roadmap</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://gist.github.com/wewnumam/e0fa4b6e659ad5d08e5a373198909ddb title=Bookmarks><span>Bookmarks</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wewnumam.github.io/id/>Beranda</a>&nbsp;»&nbsp;<a href=https://wewnumam.github.io/id/articles/>Articles</a></div><h1 class="post-title entry-hint-parent">Software Architecture Patterns</h1><div class=post-meta><span title='2025-04-29 20:27:22 +0700 +0700'>29 April 2025</span>&nbsp;·&nbsp;20 menit&nbsp;·&nbsp;4143 kata&nbsp;·&nbsp;Ahmad Adillaumam&nbsp;|&nbsp;Terjemahan:<ul class=i18n_list><li><a href=https://wewnumam.github.io/articles/software-architecture-patterns/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wewnumam/wewnumam.github.io/tree/main/content/articles/software-architecture-patterns.id.md rel="noopener noreferrer" target=_blank>Usulkan Perubahan</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Daftar isi</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#software-architecture-patterns>Software Architecture Patterns</a></li><li><a href=#tujuan-architecture-patterns>Tujuan Architecture Patterns</a></li></ul><ul><li><a href=#monolithic-architectures>Monolithic Architectures</a></li><li><a href=#distributed-architecture>Distributed Architecture</a></li><li><a href=#pilih-yang-mana>Pilih yang Mana?</a></li></ul><ul><li><a href=#technical-partitioning>Technical Partitioning</a></li><li><a href=#domain-partitioning>Domain Partitioning</a></li><li><a href=#pilih-yang-mana-1>Pilih yang Mana?</a></li></ul><ul><li><a href=#komponen-layered-architecture>Komponen Layered Architecture</a></li><li><a href=#tugas-tiap-layer>Tugas Tiap Layer</a></li><li><a href=#layers-of-isolation>Layers of Isolation</a></li><li><a href=#contoh>Contoh</a></li><li><a href=#pertimbangan>Pertimbangan</a></li></ul><ul><li><a href=#tugas-tiap-layer-1>Tugas Tiap Layer</a></li><li><a href=#contoh-1>Contoh</a></li><li><a href=#pertimbangan-1>Pertimbangan</a></li></ul><ul><li><a href=#port-dan-adapter>Port dan Adapter</a></li><li><a href=#application-layer>Application Layer</a></li><li><a href=#clean-architecture>Clean Architecture</a></li><li><a href=#contoh-2>Contoh</a></li><li><a href=#pertimbangan-2>Pertimbangan</a></li></ul><ul><li><a href=#topology>Topology</a></li><li><a href=#pertimbangan-3>Pertimbangan</a></li></ul><ul><li><a href=#topology-1>Topology</a></li><li><a href=#contoh-3>Contoh</a></li><li><a href=#pertimbangan-4>Pertimbangan</a></li></ul><ul><li><a href=#topology-2>Topology</a></li><li><a href=#fault-tolerance>Fault Tolerance</a></li><li><a href=#master-master-architecture>Master-Master Architecture</a></li><li><a href=#replication>Replication</a></li><li><a href=#contoh-4>Contoh</a></li><li><a href=#pertimbangan-5>Pertimbangan</a></li></ul><ul><li><a href=#topology-3>Topology</a></li><li><a href=#vs-master-master-architecture>vs Master-Master Architecture</a></li><li><a href=#contoh-5>Contoh</a></li><li><a href=#pertimbangan-6>Pertimbangan</a></li></ul><ul><li><a href=#topology-4>Topology</a></li><li><a href=#bounded-context>Bounded Context</a></li><li><a href=#komunikasi-antar-service>Komunikasi Antar Service</a></li><li><a href=#contoh-6>Contoh</a></li><li><a href=#pendukung>Pendukung</a></li><li><a href=#pertimbangan-7>Pertimbangan</a></li></ul><ul><li><a href=#masalah-microservices-architecture>Masalah Microservices Architecture</a></li><li><a href=#event-driven-architecture-1>Event-Driven Architecture</a></li><li><a href=#duplicate-data>Duplicate Data</a></li><li><a href=#pertimbangan-8>Pertimbangan</a></li></ul><ul><li><a href=#topology-5>Topology</a></li><li><a href=#cloud-function>Cloud Function</a></li><li><a href=#data-pipeline>Data Pipeline</a></li><li><a href=#contoh-7>Contoh</a></li><li><a href=#pertimbangan-9>Pertimbangan</a></li></ul><ul><li><a href=#triangle-shaped>Triangle-Shaped</a></li><li><a href=#triangle-shaped-topology>Triangle-Shaped Topology</a></li><li><a href=#space-based-architecture-1>Space-Based Architecture</a></li><li><a href=#topology-6>Topology</a></li><li><a href=#contoh-data-grid>Contoh Data Grid</a></li><li><a href=#pertimbangan-10>Pertimbangan</a></li></ul><ul><li><a href=#software-architecture-patterns-lainnya>Software Architecture Patterns Lainnya</a></li></ul></nav></div></details></div><div class=post-content><h1 id=pendahuluan>Pendahuluan<a hidden class=anchor aria-hidden=true href=#pendahuluan>#</a></h1><ul><li>Sudah jadi hal yang biasa, biasanya programmer akan membuat perangkat lunak tanpa persiapan yang matang.</li><li>Hal ini kadang membuat perangkat lunak menjadi sulit di-maintain dan dikembangkan ketika sudah terlanjur dibuat.</li><li>Oleh karena itu, sebelum melakukan pembuatan perangkat lunak yang besar, salah satu hal yang wajib dilakukan adalah memilih arsitektur yang akan digunakan.</li><li>Dalam pemilihan arsitektur perangkat lunak, kita harus mengerti kelebihan dan kekurangannya, agar membantu dalam pembuatan perangkat lunak yang akan dilakukan.</li></ul><h2 id=software-architecture-patterns>Software Architecture Patterns<a hidden class=anchor aria-hidden=true href=#software-architecture-patterns>#</a></h2><ul><li>Architecture Patterns merupakan kumpulan gaya arsitektur dalam pembuatan perangkat lunak.</li><li>Ada banyak sekali Architecture Patterns, dan setiap pattern memiliki kelebihan dan kekurangan masing-masing. Di dalam Architecture Patterns tidak ada benar dan salah, tapi cocok atau tidak.</li><li>Programmer perlu tahu tentang materi ini agar bisa menentukan pattern apa yang akan digunakan ketika membuat perangkat lunak.</li></ul><h2 id=tujuan-architecture-patterns>Tujuan Architecture Patterns<a hidden class=anchor aria-hidden=true href=#tujuan-architecture-patterns>#</a></h2><ul><li>Tiap Architecture Pattern memiliki karakteristik seperti mudah dikembangkan, scalable dan mudah di-maintain.</li><li>Harapannya, dengan menggunakan Architecture Pattern yang tepat saat pembuatan perangkat lunak, hasil perangkat lunak yang kita buat akan mudah dikembangkan kedepannya.</li></ul><h1 id=architecture-classification>Architecture Classification<a hidden class=anchor aria-hidden=true href=#architecture-classification>#</a></h1><ul><li>Software Architecture Patterns secara garis besar dibagi menjadi dua klasifikasi, Monolithic dan Distribute.</li><li>Monolithic adalah single deployment unit atau berjalan dalam satu aplikasi.</li><li>Distributed adalah multiple deployment units, biasanya terdiri dari beberapa aplikasi.</li></ul><h2 id=monolithic-architectures>Monolithic Architectures<a hidden class=anchor aria-hidden=true href=#monolithic-architectures>#</a></h2><ul><li>Monolithic Architecture secara umum sangat sederhana dibandingkan Distributed Architecture.</li><li>Desain aplikasi Monolithic lebih sederhana dan mudah diimplementasikan.</li><li>Aplikasi yang menggunakan Monolithic Architecture akan sangat cepat dibuat dan didistribusikan.
<img alt="Monolithic Architectures" loading=lazy src=https://i.imgur.com/YQkdFLv.png></li></ul><h2 id=distributed-architecture>Distributed Architecture<a hidden class=anchor aria-hidden=true href=#distributed-architecture>#</a></h2><ul><li>Distributed Architecture biasanya terdiri dari beberapa aplikasi yang bekerja bersamaan, berbeda dengan aplikasi Monolithic yang hanya satu aplikasi.</li><li>Biasanya dalam Distributed Architecture, setiap unit aplikasi disebut Service.</li><li>Pengembangan Distributed Architecture memang lebih kompleks dibandingkan dengan Monolithic Architecture, namun menawarkan keuntungan seperti toleransi kesalahan (fault tolerance), misal ketika ada satu Service gagal, Service lain masih bisa berjalan dengan normal</li></ul><p><img alt="Distributed Architecture" loading=lazy src=https://i.imgur.com/CAHCQzg.png></p><h2 id=pilih-yang-mana>Pilih yang Mana?<a hidden class=anchor aria-hidden=true href=#pilih-yang-mana>#</a></h2><ul><li>Pada saat pembuatan aplikasi, kadang kita bingung menentukan harus menggunakan arsitektur Monolithic atau Distributed?</li><li>Jika aplikasi yang akan kita buat sederhana atau masih belum jelas secara business requirement, sangat disarankan menggunakan Monolithic, karena mudah untuk dibuat.</li><li>Namun jika aplikasi yang akan kita buat sudah sangat jelas, dan juga memang membutuhkan, scalability yang baik, termasuk fault tolerance yang baik, maka kita bisa gunakan arsitektur Distributed.</li></ul><h1 id=architecture-partitioning>Architecture Partitioning<a hidden class=anchor aria-hidden=true href=#architecture-partitioning>#</a></h1><ul><li>Selain dilihat secara klasifikasi monolithic atau distributed, software architecture juga bisa dilihat secara struktur partisinya.</li><li>Software architecture baik itu monolithic atau distributed, secara partisi bisa dibagi berdasarkan teknis atau domain.</li><li>Partisi secara struktur bisa digunakan di monolithic atau distributed.</li></ul><h2 id=technical-partitioning>Technical Partitioning<a hidden class=anchor aria-hidden=true href=#technical-partitioning>#</a></h2><ul><li>Arsitektur Technical Partitioning membagi komponen-komponen dalam system atau aplikasi secara teknis.</li><li>Contoh arsitektur klasik yang sering digunakan adalah Layered (N-Tier) Architecture.</li><li>Dalam Technical Partitioning, komponen dalam system dikelompokan secara teknis, misal :<ul><li>Presentation Layer merupakan komponen yang menangani user interface.</li><li>Business Layer, merupakan komponen yang menangani logika dan aturan bisnis.</li><li>Persistence Layer, merupakan komponen yang menangani interaksi dengan sistem basis data.</li><li>Database Layer, merupakan komponen untuk menyimpan data.</li></ul></li></ul><p><img alt="Technical Partitioning" loading=lazy src=https://i.imgur.com/jFaaqq7.png></p><h2 id=domain-partitioning>Domain Partitioning<a hidden class=anchor aria-hidden=true href=#domain-partitioning>#</a></h2><ul><li>Berbeda dengan Technical Partitioning, dalam Domain Partitioning, pembagian struktur komponen dalam system dikelompokan berdasarkan Domain/Fitur/ Departemen secara bisnisnya.</li><li>Artinya semua Technical Partitioning seperti Presentation, Business Logic, Persistence, digabung dalam per domain system.</li><li>Partisi system berdasarkan Domain, populer sejak dikenalkan dalam buku berjudul &ldquo;Domain Driven Design&rdquo; karya Eric Evans.</li></ul><p><img alt="Domain Partitioning" loading=lazy src=https://i.imgur.com/UA9tXUz.png></p><h2 id=pilih-yang-mana-1>Pilih yang Mana?<a hidden class=anchor aria-hidden=true href=#pilih-yang-mana-1>#</a></h2><ul><li>Technical ataupun Domain Partitioning memiliki kelebihan dan kekurangan, namun secara pribadi saya rekomendasikan gunakan:</li><li>Technical Partitioning ketika aplikasi yang akan dibuat sederhana dan tidak kompleks, Selain itu ketika jumlah anggota tim pengembang tidak terlalu banyak.</li><li>Domain Partitioning ketika aplikasi yang akan dibuat kompleks dan fitur aplikasi sangat banyak. Dan sangat cocok ketika anggota tim pengembang banyak pembagian tim berdasarkan jenis domainnya.</li></ul><h1 id=layered-architecture>Layered Architecture<a hidden class=anchor aria-hidden=true href=#layered-architecture>#</a></h1><ul><li>Layered Architecture dikenal juga dengan N -Tier Architecture.</li><li>Arsitektur ini adalah salah satu standard arsitektur untuk kebanyakan aplikasi, di mana aplikasi dibagi secara teknis.</li><li>Karena arsitektur ini sangat banyak diketahui oleh pengembang perangkat lunak, hal ini menjadikan arsitektur ini menjadi salah satu pilihan yang banyak digunakan.</li></ul><h2 id=komponen-layered-architecture>Komponen Layered Architecture<a hidden class=anchor aria-hidden=true href=#komponen-layered-architecture>#</a></h2><ul><li>Layered Architecture dibagi secara teknis, oleh karena itu komponen-komponen dalam Layered Architecture sama dengan Technical Partition.</li><li>Rata-rata banyak yang membagi menjadi 4 layer, Presentation Layer, Business Layer, Persistence Layer dan Database Layer. Namun tidak menutup kemungkinan bisa lebih banyak layer ketika aplikasi sangat kompleks.</li></ul><p><img alt="Komponen Layered Architecture" loading=lazy src=https://i.imgur.com/JrUPelT.png></p><h2 id=tugas-tiap-layer>Tugas Tiap Layer<a hidden class=anchor aria-hidden=true href=#tugas-tiap-layer>#</a></h2><ul><li>Setiap layer di Layered Architecture memiliki tugas masing-masing.</li><li>Presentation Layer bertanggung jawab menangani semua user interface.</li><li>Business Layer bertanggung jawab mengeksekusi permintaan logika atau aturan bisnis yang sesuai permintaan.</li><li>Persistence Layer bertanggung jawab untuk berinteraksi dengan database untuk melakukan pengolahan data di database.</li><li>Database Layer bertanggung jawab untuk menyimpan semua data aplikasi.</li></ul><h2 id=layers-of-isolation>Layers of Isolation<a hidden class=anchor aria-hidden=true href=#layers-of-isolation>#</a></h2><ul><li>Dalam Layered Architecture, tiap Layer akan terisolasi, dan arah komunikasi hanya dilakukan dengan layer di bawah atau di atasnya.</li><li>Artinya, misal ketika Presentation Layer ingin mengambil data Product, Presentation Layer akan mengirim request ke Business Layer, lalu akan mengambil data ke Persistence Layer dan baru masuk ke Database Layer.</li><li>Tidak direkomendasikan untuk langsung mengakses dari Presentation Layer langsung ke Database Layer.</li></ul><h2 id=contoh>Contoh<a hidden class=anchor aria-hidden=true href=#contoh>#</a></h2><ul><li>Setelah tahu cara kerja Layered Architecture, maka kita bisa dengan mudah menggambarkan alur yang harus dibuat ketika membuat aplikasi.</li><li>Misal kita ingin menampilkan halaman Product, namun di dalam halaman Product kita juga ingin menampilkan data Seller-nya.</li><li>Maka kita bisa buat alur aplikasi seperti pada diagram selanjutnya.</li></ul><p><img alt="Contoh Alur Layered Architecture" loading=lazy src=https://i.imgur.com/UbjXlTr.png></p><h2 id=pertimbangan>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan>#</a></h2><ul><li>Layered Architecture adalah salah satu arsitektur yang banyak dimengerti dan digunakan.</li><li>Gunakan Layered Architecture jika kita masih bingung ingin menggunakan arsitektur apa, karena ini adalah arsitektur yang bagus untuk memulai aplikasi.</li><li>Namun jangan gunakan Layered Architecture ketika pembagian tim di perusahaan sudah berdasarkan domain, lebih cocok menggunakan Distributed Architecture yang akan kita bahas di materi-materi selanjutnya.</li></ul><h1 id=model-view-controller-architecture>Model-View-Controller Architecture<a hidden class=anchor aria-hidden=true href=#model-view-controller-architecture>#</a></h1><ul><li>Model View Controller (MVC) Architecture merupakan salah satu arsitektur yang sangat populer ketika membuat Web.</li><li>MVC mirip dengan Layered Architecture, hanya saja layer-nya berbeda.</li><li>Dalam MVC pusat interaksi antar layer biasanya dilakukan oleh Controller.</li></ul><p><img alt="Model-View-Controller Architecture" loading=lazy src=https://i.imgur.com/TSq4w4X.png></p><h2 id=tugas-tiap-layer-1>Tugas Tiap Layer<a hidden class=anchor aria-hidden=true href=#tugas-tiap-layer-1>#</a></h2><ul><li>Dalam MVC, setiap layer memiliki tugas masing-masing.</li><li>Controller adalah layer yang bertanggung jawab untu k menerima request dan mengeksekusi logika dan aturan bisnis yang terjadi di aplikasi.</li><li>Model merupakan layer yang bertanggung jawab sebagai representasi data di database dan juga berinteraksi ke database.</li><li>View merupakan layer yang berisi template untuk tampilan halaman web.</li><li>Database merupakan layer untuk menyimpan data aplikasi.</li></ul><h2 id=contoh-1>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-1>#</a></h2><p>Misal kita memiliki web di mana terdapat satu halaman web yang perlu untuk menampilkan data wishlist. Pada halaman Itu, selain data wishlist, kita juga harus menampilkan detail product yang terdapat di wishlist tersebut.</p><p><img alt="Contoh Model-View-Controller Architecture" loading=lazy src=https://i.imgur.com/7Fh4CWw.png></p><h2 id=pertimbangan-1>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-1>#</a></h2><ul><li>MVC adalah pilihan utama ketika kita ingin membuat aplikasi Web.</li><li>Banyak sekali web framework yang sudah secara otomatis menggunakan arsitektur ini seperti Laravel, NestJS, Rails, Django, dan lain-lain.</li><li>Namun ketika kita membuat RESTful API misalnya, kita tidak wajib mengikuti aturan MVC, karena biasanya kita tidak memerlukan layer View. Pada kasus seperti ini, kita bisa saja menggabungkan arsitektur MVC ini dengan Layered Architecture.</li></ul><h1 id=hexagonal-architecture>Hexagonal Architecture<a hidden class=anchor aria-hidden=true href=#hexagonal-architecture>#</a></h1><ul><li>Salah satu masalah ketika menggunakan Layered Architecture adalah, perubahan jenis teknologi yang digunakan, akan menyulitkan pengembangan.</li><li>Contoh ketika kita harus mengganti teknologi database yang digunakan, secara otomatis akan terjadi perombakan besar-besaran pada kode program Persistence Layer dan Database Layer, yang mungkin bisa menyebabkan perombakan juga pada Business Layer.</li><li>Hexagonal Architecture merupakan arsitektur yang dikembangkan dari Layered Architecture, namun lebih baik ketika menangani perubahan teknologi yang terjadi.</li><li>Hexagonal Architecture juga dikenal dengan Port & Adapter Architecture</li></ul><p><img alt="Hexagonal Architecture" loading=lazy src=https://i.imgur.com/g98YhPu.png></p><h2 id=port-dan-adapter>Port dan Adapter<a hidden class=anchor aria-hidden=true href=#port-dan-adapter>#</a></h2><ul><li>Hexagonal Architecture sebenarnya dikenalkan dengan nama Pert & Adapter Architecture, namun saat ini lebih populer dengan nama Hexagonal Architecture.</li><li>Port merupakan technology-agnostic yang merupakan sebuah OOP (Object Oriented Programming) Interface, yang digunakan oleh kode aplikasi untuk berkomunikasi dengan pihak lain.</li><li>Adapter merupakan bagian yang berinteraksi langsung melalui Port, dan menggunakan teknologi yang sudah ditentukan.</li></ul><p><img alt="Port dan Adapter" loading=lazy src=https://i.imgur.com/AAV5hSj.png></p><h2 id=application-layer>Application Layer<a hidden class=anchor aria-hidden=true href=#application-layer>#</a></h2><ul><li>Dalam Hexagonal Architecture, Application Layer akan berisi logika dan aturan bisnis, di mana kode yang dibuat akan berinteraksi hanya dengan Port, tanpa tahu Adapter yang digunakan.</li><li>Hal ini agar tercapainya technology agnostic, sehingga ketika Adapter diubah, Application Layer tidak perlu berubah.</li><li>Selain itu, di dalam Application Layer, terdapat Domain Layer, yang berisikan representasi data domain aplikasi.</li><li>Bagian Driving, biasanya disebut User Interface/Transport Layer/Gateway, yaitu sumber request masuk ke aplikasi.</li><li>Bagian Driven, biasanya disebut Infrastructure/Data Source/External Interfaces, yaitu target data keluar dari aplikasi.</li></ul><p><img alt="Application Layer" loading=lazy src=https://i.imgur.com/gBwZEBA.png></p><h2 id=clean-architecture>Clean Architecture<a hidden class=anchor aria-hidden=true href=#clean-architecture>#</a></h2><ul><li>Saat ini, terkenal juga arsitektur dengan nama Clean Architecture.</li><li>Jangan bingung jika harus memilih Hexagonal Architecture atau Clean Architecture.</li><li>Sebenarnya Clean Architecture tidak berbeda jauh dengan Hexagonal Architecture, bahkan penulis buku Clean Architecture pun memang sudah menjelaskan bahwa salah satu referensi Clean Architecture adalah dari Hexagonal Architecture.</li></ul><h2 id=contoh-2>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-2>#</a></h2><ul><li>Misal kita memiliki aplikasi Web toko online, di mana kita akan membuat halaman pembayaran.</li><li>di mana saat melakukan data pembayaran selain disimpan di database, akan dikirim ke Payment Gateway.</li></ul><p><img alt="Contoh Hexagonal Architecture" loading=lazy src=https://i.imgur.com/hu9jRuY.png></p><h2 id=pertimbangan-2>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-2>#</a></h2><ul><li>Hexagonal Architecture merupakan salah satu arsitektur yang bagus digunakan ketika kita akan membuat aplikasi yang kompleks dan agar aplikasinya technology agnostic sehingga mudah diganti-ganti.</li><li>Namun pengembangan Hexagonal Architecture tidaklah semudah Layered Architecture, sehingga jika pengembang belum familiar dengan Hexagonal Architecture, maka bisa terkendala ketika proses pengembangan.</li></ul><h1 id=microkernel-architecture>Microkernel Architecture<a hidden class=anchor aria-hidden=true href=#microkernel-architecture>#</a></h1><ul><li>Microkernel Architecture sangat flexible dan extensible, sehingga pengembang bisa dengan mudah menambah fitur pada aplikasi dalam bentuk extension atau plug-in, tanpa takut menggangu fungsionalitas dari aplikasinya itu sendiri.</li><li>Oleh karena itu, Microkernel Architecture juga sering disebut sebagai Plug-in Architecture.</li><li>Microkernel Architecture sangat banyak digunakan pada aplikasi berbasis desktop biasanya, contoh seperti Visual Studio, Eclipse, dan lain-lain, di mana ada banyak sekali extension atau plug-in yang tersedia untuk aplikasi tersebut.</li></ul><p><img alt="Microkernel Architecture" loading=lazy src=https://i.imgur.com/tM4zGf2.png></p><h2 id=topology>Topology<a hidden class=anchor aria-hidden=true href=#topology>#</a></h2><ul><li>Dalam Microkernel Architecture, hanya terdapat dua layer, Core System dan juga Plugin Modules.</li><li>Logic aplikasi di Microkernel Architecture biasanya di tempatkan di Plugin, maka dari itu arsitektur ini terlihat seperti Hexagonal Architecture, tetapi sebenarnya bukan.</li><li>Dalam Hexagonal Architectwe, logic aplikasi ditempatkan di aplikasi, sedangkan di Microkernel Architecture, detail logic aplikasi berada di tiap Plugin masing-masing.</li></ul><h2 id=pertimbangan-3>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-3>#</a></h2><ul><li>Microkernel Architecture sangat populer digunakan ketika membuat aplikasi Desktop berbasis plugin, seperti Visual Studio, Eclipse, IntelliJ IDEA Ghkan seperti Browser.</li><li>Gunakan Microkernel Architecture jika memang kita ingin membuat aplikasi yang berbasis Plugin.</li><li>Salah satu keunggulan Microkernel Architecture adalah, orang lain bisa berkontribusi membuat Plugin untuk aplikasi kita.</li></ul><h1 id=client-server-architecture>Client-Server Architecture<a hidden class=anchor aria-hidden=true href=#client-server-architecture>#</a></h1><ul><li>Client-Server Architecture adalah salah satu Distributed System Architecture yang banyak dikenal dan digunakan.</li><li>Arsitektur ini sangat sederhana, di mana terdapat aplikasi Client dan Server yang saling berinteraksi.</li><li>Biasanya komunikasi antara Client dan Server menggunakan jaringan TCP/IP, walaupun tidak tertutup kemungkinan menggunakan jaringan lain seperti UDP.</li></ul><p><img alt="Client-Server Architecture" loading=lazy src=https://i.imgur.com/NWSKhhf.png></p><h2 id=topology-1>Topology<a hidden class=anchor aria-hidden=true href=#topology-1>#</a></h2><ul><li>Client adalah aplikasi yang digunakan oleh pengguna dan berinteraksi langsung dengan pengguna, Biasanya aplikasi Client adalah aplikasi yang berbasis user interface, baik itu berupa Web, Desktop atau bisa saja berbasis Terminal, Client akan mengirim semua request yang diminta oleh pengguna ke aplikasi Server</li><li>Server adalah inti dari aplikasi, di mana semua logika dan aturan bisnis dilakukan di Server, Server akan menjalankan perintah yang diminta oleh Client, dan mengembalikan data yang diminta ke Client</li><li>Keuntungan menggunakan Client-Server Architecture adalah, kita bisa menjalankan banyak aplikasi jenis Client hanya dengan menggunakan satu aplikasi Server</li></ul><h2 id=contoh-3>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-3>#</a></h2><ul><li>Client-Server Architecture adalah arsitektur yang saat ini sangat banyak digunakan, bahkan mungkin secara tidak sadar, kita sudah menggunakan arsitektur ini.</li><li>Ketika kita membuat aplikasi Mobile lalu terkoneksi ke RESTful API, sebenarnya itu adalah Client-Server Architecture.</li></ul><p><img alt="Contoh Client-Server Architecture" loading=lazy src=https://i.imgur.com/mhQdLau.png></p><h2 id=pertimbangan-4>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-4>#</a></h2><ul><li>Saat kita ingin membuat aplikasi, yang ingin memisahkan aplikasi Client, atau bahkah membuat banyak jenis aplikasi Client, maka arsitektur Client-Server sangat cocok digunakan</li><li>Namun jika kita ingin membuat aplikasi yang standalone, tidak butuh menyimpan data di Server, maka kita tidak butuh membuat aplikasi Client-Server, contoh seperti aplikasi editor untuk Photo, Video dan sejenisnya</li></ul><h1 id=master-slave-architecture>Master-Slave Architecture<a hidden class=anchor aria-hidden=true href=#master-slave-architecture>#</a></h1><ul><li>Master-Slave Architecture merupakan arsitektur di mana aplikasi bisa mendistribusikan semua pekerjaannya ke aplikasi lain.</li><li>Aplikasi yang memerintah sza aplikasi dinamakan Master, dan aplikasi yang menerima perintah dinamakan Slave.</li><li>Sama seperti Client-Server Architecture, biasanya komunikasi Master dan Slave menggunakan jaringan TCP/IP.</li></ul><p><img alt="Master-Slave Architecture" loading=lazy src=https://i.imgur.com/ISP00p4.png></p><h2 id=topology-2>Topology<a hidden class=anchor aria-hidden=true href=#topology-2>#</a></h2><ul><li>Biasanya, semua request ke aplikasi akan lewat aplikasi Master.</li><li>Semua pekerjaan yang diterima oleh Master, biasanya akan didistribusikan ke aplikasi Slave.</li><li>Dengan begitu, pekerjaan bisa lebih cepat karena bisa dikerjakan oleh banyak aplikasi Slave.</li><li>Pada diagram, kita hanya membuat 3 aplikasi Slave, namun kenyataanya, tidak ada batasan jumlah aplikasi Slave.</li></ul><h2 id=fault-tolerance>Fault Tolerance<a hidden class=anchor aria-hidden=true href=#fault-tolerance>#</a></h2><ul><li>Salah satu keunggukan Master-Slave Architecture adalah, Fault Torelance, di mana ketika misal terjadi kesalahan yang menyebabkan salah satu aplikasi Slave mati, maka pekerjaan masih bisa dikerjaan oleh aplikasi Slave Iain.</li><li>Begitu juga ketika terjadi masalah yang menyebabkan aplikasi Master mati, maka secara otomatis salah satu Slave akan dipromosikan menjadi Master baru.</li></ul><p><img alt="Fault Tolerance" loading=lazy src=https://i.imgur.com/cQ3Accc.png></p><h2 id=master-master-architecture>Master-Master Architecture<a hidden class=anchor aria-hidden=true href=#master-master-architecture>#</a></h2><ul><li>Salah satu kekurangan Master-Slave Architecture adaIah, semua request harus melewati aplikasi Master, sehingga ketika terjadi kelambatan di aplikasi Master, secara otomatis semua pengguna akan merasakan dampaknya, padahal mungkin aplikasi Slave tidak lambat.</li><li>Pada kasus seperti itu, terdapat juga Master-Master Architecture, di mana ini adalah improvement dari Master-Slave Architecture.</li><li>Yang membedakan Master-Master Architecture adalah, semua aplikasi bisa berjalan sebagai Master, sehingga bisa menerima request dari pengguna secara mandiri</li><li>Dan karena semua aplikasi adalah Master, tiap aplikasi bisa saja mengirim request ke aplikasi Iain, ketika misal aplikasi sudah terlalu banyak menangani request dari pengguna.</li></ul><p><img alt="Master-Master Architecture" loading=lazy src=https://i.imgur.com/kNpvSUc.png></p><h2 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h2><ul><li>Yang perlu diingat dalam Master-Slave/Master-Master Architecture, biasanya data di aplikasi selalu di replikasi/duplikasi ke semua Slave/Master.</li><li>Hal ini agar data selalu sama, sehingga pekerjaan yang dikerjakan oleh semua aplikasi Slave/Master akan selalu konsisten.</li></ul><h2 id=contoh-4>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-4>#</a></h2><ul><li>Master-Slave/Master-Master Architecture jangan digunakan ketika membuat aplikasi sistem informasi, arsitektur ini rata-rata sering digunakan ketika kita membuat aplikasi stateful! (menyimpan data) seperti sistem basis data.</li><li>Hampir kebanyakan aplikasi sistem basis data seperti MySQL, PostgreSQL, MongoDB mengimplementasikan arsitektur Master-Slave Architecture</li><li>Atau seperti aplikasi sistem basis data Elasticsearch dan Cassandra, yang menggunakan Master-Master Architecture.</li></ul><h2 id=pertimbangan-5>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-5>#</a></h2><ul><li>Gunakan arsitektur Master-Slave/Master-Master ketika kita ingin membuat aplikasi yang stateful! (menyimpan data)</li><li>Jika kita membuat aplikasi yang stateless (tidak menyimpan data), maka disarankan tidak menggunakan arsitektur ini.</li></ul><h1 id=peer-to-peer-architecture>Peer-to-Peer Architecture<a hidden class=anchor aria-hidden=true href=#peer-to-peer-architecture>#</a></h1><ul><li>Peer-to-Peer Architecture merupakan arsitektur yang hampir mirip dengan Client-Server Architecture.</li><li>Hanya saja, dalam Peer-to-Peer, semua aplikasi bisa menjadi Client dan juga Server secara berbarengan.</li><li>Biasanya logika aplikasi akan terpusat di aplikasi Server, pada Peer-to-Peer, logika aplikasi tidak terpusat di satu aplikasi, semua aplikasi bisa menjadi Server sekaligus Client.</li></ul><p><img alt="Peer-to-Peer Architecture" loading=lazy src=https://i.imgur.com/QIkp4fF.png></p><h2 id=topology-3>Topology<a hidden class=anchor aria-hidden=true href=#topology-3>#</a></h2><ul><li>Dalam Peer-to-Peer Architecture seakan terlihat sederhana, namun sebenarnya arsitektur ini sangat kompleks.</li><li>Setiap Peer bisa menjadi Client yang melakukan request ke Peer lain, atau bahkan menjadi Server pada saat yang bersamaan dengan mengirim response ke Peer lain.</li><li>Oleh karena itu pembuatan aplikasi Peer-to-Peer Architecture sangat kompleks karena setiap Peer harus tahu ketika terdapat Peer baru, karena pada kenyataannya Peer baru bisa datang dan hilang kapan saja.</li></ul><h2 id=vs-master-master-architecture>vs Master-Master Architecture<a hidden class=anchor aria-hidden=true href=#vs-master-master-architecture>#</a></h2><ul><li>Apa bedanya Peer-to-Peer Architecture dan Master-Master Architecture?</li><li>Pada Peer-to-Peer, tiap Peer bisa menjadi Client ataupun Server.</li><li>Sedangkan pada Master-Master, tiap Master adalah Server, biasanya Client adalah aplikasi yang terpisah dan terkoneksi ke Master-Master dengan arsitektur Client-Server.</li></ul><h2 id=contoh-5>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-5>#</a></h2><ul><li>Peer-to-Peer banyak sekali digunakan untuk aplikasi berbagi file seperti Torrent misalnya, di mana setiap orang bisa berbagi file, sekaligus meminta file ke Peer lain di dalam jaringan Torrent-nya.</li><li>Selain itu, Peer-to-Peer juga sering digunakan dalam Cryptocurrency di mana semua data terdistribusi di semua aplikasi Peer untuk menjaga data tetap aman karena untuk mengubah data, kita harus mengubah seluruh data di semua Peer, dan itu sangat sulit untuk dilakukan.</li></ul><h2 id=pertimbangan-6>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-6>#</a></h2><ul><li>Peer-to-Peer Architecture mungkin terlihat sangat menarik, namun ini adalah jenis arsitektur yang jarang sekali digunakan, kecuali pada jenis aplikasi yang membutuhkan logika yang tidak terpusat.</li><li>Peer-to-Peer Architecture juga merupakan arsitektur yang sangan scalable, karena sulit untuk terjadi kegagalan sistem karena semua logic terdistribusi di semua Peer</li><li>Kekurangannya adalah, karena kita tidak bisa menjadi kualitas resource di tiap Peer, jadi, besar kemungkinan kualitas dan kecepatan aplikasi tidak bisa dijaga dengan baik, terutama jika Peer berjalan di hardware dengan resource yang kurang.</li></ul><h1 id=microservices-architecture>Microservices Architecture<a hidden class=anchor aria-hidden=true href=#microservices-architecture>#</a></h1><ul><li>Microservices Architecture adalah jenis arsitektur yang saat sedang banyak sekali digunakan Oleh banyak orang Namun arsitektur ini bukanlah jenis arsitektur yang sederhana, ini adalah jenis arsitektur yang kompleks.</li><li>Pada Microservices Architectures, system akan dibuat dalam jumlah aplikasi-aplikasi kecil atau disebut Service, dan digunakan untuk menyelesaikan tugas spesifik tertentu saja.</li><li>Selain itu pada arsitektur ini, tiap Service akan di deploy dan dijalankan secara mandiri</li><li>Pada arsitektur ini, tidak aneh jika sebuah system memiliki ratusan bahkan ribuan Service mandiri, hal ini karena tiap Service memang memiliki tugas masing-masing.</li></ul><p><img alt="Microservices Architecture" loading=lazy src=https://i.imgur.com/QHtOgoT.png></p><h2 id=topology-4>Topology<a hidden class=anchor aria-hidden=true href=#topology-4>#</a></h2><ul><li>Biasanya dalam Microservices Architecture, setiap Service akan berjalan secara independent dan memiliki database masing-masing, tidak melakukan sharing database dengan Service lain.</li><li>Biasanya juga tiap Service tidak akan di expose secara terbuka ke pengguna, melainkan pengguna akan melewati API Gateway, yaitu aplikasi yang bertugas sebagai gerbang untuk menerima request dan meneruskan ke Service yang dituju.</li><li>Karena tiap Service memiliki tugas masing-masing, maka tidak jarang database yang digunakanpun bisa berbeda-beda, hal ini karena biasanya Service akan menggunakan database yang sesuai dengan tugas yang harus dikerjakan.</li></ul><h2 id=bounded-context>Bounded Context<a hidden class=anchor aria-hidden=true href=#bounded-context>#</a></h2><ul><li>Seperti yang dijelaskan sebelumnya, bahwa tiap Service akan memiliki dan melakukan manajemen database-nya sendiri.</li><li>Artinya database dan table tersebut hanya boleh diakses Oleh Service tersebut</li><li>Contoh misal ketika kita memiliki Service yang digunakan untuk melakukan management data Seller, maka Seller Service yang hanya boleh melakukan management data Seller tersebut.</li><li>Konsep ini, disebut dengan Bounded Context, yang dikenalkan Oleh Eric Evans pada buku Domain-Driven Design.</li></ul><p><img alt="Bounded Context" loading=lazy src=https://i.imgur.com/4e1CUGn.png></p><h2 id=komunikasi-antar-service>Komunikasi Antar Service<a hidden class=anchor aria-hidden=true href=#komunikasi-antar-service>#</a></h2><ul><li>Dengan adanya Bounded Context, artinya tidak ada yang boleh mengakses database Seller secara langsung dari Service lain kecuali Seller Service.</li><li>Jika ada Service lain yang membutuhkan data Seller, maka Service lain tersebut harus meminta data Seller ke Seller Service, dengan cara komunikasi yang sudah ditentukan, misal RESTful API (Client-Server Architecture).</li></ul><h2 id=contoh-6>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-6>#</a></h2><ul><li>Pada halaman web toko online, kita ingin menampilkan data detail Product.</li><li>Namun pada halaman data detail Product, selain informasi Product, kita juga ingin menampilkan data Seller yang menjual Product tersebut.</li><li>Pada kasus ini, kita bisa mengambil data Product ke Product Service, lalu Product Service meminta data Seller ke Seller Service.</li></ul><p><img alt="Contoh Microservices Architecture" loading=lazy src=https://i.imgur.com/8wFM0gc.png></p><h2 id=pendukung>Pendukung<a hidden class=anchor aria-hidden=true href=#pendukung>#</a></h2><ul><li>Untuk menggunakan Microservices Architecture biasanya tidak hanya melibatkan tim programmer.</li><li>Banyak sekali yang harus diubah seperti infrastructure dan tim product/bisnis.</li><li>Hal ini karena biasanya dalam Microservice Architecture, pembagian Service akan dilakukan berdasarkan domain bisnis, jadi tidak sederhana membuat aplikasi kecil.</li><li>Pada beberapa kasus, kesalahan pembuatan jenis Service bisa mempersulit tim pengembang, Oleh karena itu diperlukan orang Domain Expert atau yang sudah ahli di bidangnya secara bisnis.</li></ul><h2 id=pertimbangan-7>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-7>#</a></h2><ul><li>Microservice Architecture biasanya digunakan di perusahaan yang sudah besar dengan tim pengembang yang banyak, hal ini dikarenakan arsitektur ini menuntut banyak sekali pekerjaan selain pekerjaan membuat aplikasi, seperti infrastruktur, automation, deployment dan Iain-Iain.</li><li>Jangan gunakan arsitektur ini jika tim masih kecil, kita bisa mulai dengan Monolith Architecture dan Layered Architecture, jika sudah waktunya membutuhkan scaling tim secara cepat, kita baru bisa mempertimbangkan penggunaan Microservices Architecture.</li></ul><h1 id=event-driven-architecture>Event-Driven Architecture<a hidden class=anchor aria-hidden=true href=#event-driven-architecture>#</a></h1><h2 id=masalah-microservices-architecture>Masalah Microservices Architecture<a hidden class=anchor aria-hidden=true href=#masalah-microservices-architecture>#</a></h2><ul><li>Dengan meningkatnya penggunaan Microservices Architecture, akhirnya terdapat salah satu masalah yang sering dialami pengguna arsitektur tersebut, yaitu ketergantungan antar Service.</li><li>Contoh pada kasus sebelumnya misalnya, ketika Seller Service bermasalah, misal mati, maka kita tidak bisa melihat data Product, hal ini karena Product Service butuh memanggil Seller Service ketika ingin menampilkan data Product.</li></ul><h2 id=event-driven-architecture-1>Event-Driven Architecture<a hidden class=anchor aria-hidden=true href=#event-driven-architecture-1>#</a></h2><ul><li>Event-Driven Architecture merupakan arsitektur yang menggunakan Async Proses untuk saling berkomunikasi antar Service.</li><li>Biasanya, pada arsitektur ini, Service akan mengirim setiap perubahan data yang terjadi pada Service tersebut ke aplikasi bernama Message Broker dalam bentuk data Event.</li><li>Pengirim data Event kita sebut dengan nama Producer/Publisher.</li><li>Service yang membutuhkan data Event-nya akan mengambil data tersebut pada Message Broker.</li><li>Penerima data Event kita sebut dengan nama Consumer/Listener.</li></ul><p><img alt="Event-Driven Architecture" loading=lazy src=https://i.imgur.com/KFTW5Ec.png></p><h2 id=duplicate-data>Duplicate Data<a hidden class=anchor aria-hidden=true href=#duplicate-data>#</a></h2><ul><li>Seperti yang sudah kita tahu, dalam Microservices Architecture terdapat aturan Bounded Context, di mana data hanya bisa diakses Oleh Service itu sendiri.</li><li>Pada kasus Event-Driven Architecture, karena kita tidak akan memanggil secara Sync ke Service Lain (seperti menggunakan API Call), maka biasanya Service akan meng-consume event data dan men-duplicate data yang dibutuhkan di database Service itu.</li><li>Pada kasus sebelumnya, contohnya Product Service akan meng-consume data Seller Event, lalu menyimpan data Seller ke database Product sebagai data duplicate.</li></ul><p><img alt="Contoh Event-Driven Architecture" loading=lazy src=https://i.imgur.com/fIO65AG.png></p><h2 id=pertimbangan-8>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-8>#</a></h2><ul><li>Event-Driven Architecture saat ini banyak yang menggunakan, karena permasalahan yang terjadi di Microservices Architecture, namun perlu diperhatikan, ada juga akibat yang terjadi ketika kita menggunakan Async Process.</li><li>Pada kasus sebelumnya, kita harus memastikan data Seller Event diterima dengan baik Oleh Product Service, jika gagal secara otomatis data Seller tidak akan ada di database Product.</li><li>Async Process juga akan menyebabkan proses menjadi delay, Oleh karena itu kadang pengguna tidak menerima hasil secara realtime, karena Async Process belum selesai</li><li>Ketika terjadi masalah pada Async Process, melakukan pencarian masalah lebih sulit dibanding Sync Process pada arsitektur Microservices.</li></ul><h1 id=pipeline-architecture>Pipeline Architecture<a hidden class=anchor aria-hidden=true href=#pipeline-architecture>#</a></h1><ul><li>Pipeline Architecture adalah arsitektur yang erat kaitannya dengan Data Stream (aliran data).</li><li>Pada beberapa kasus, kadang kita menemui sumber data yang masuk tanpa henti, misal data log aktivitas pengguna misalnya.</li><li>Pada kasus seperti ini, menyimpan data di database akan sangat menyulitkan untuk memprosesnya, karena data masuk biasanya dalam jumlah banyak dan terus menerus.</li><li>Pipeline Architecture adalah arsitektur di mana kita memanfaatkan Message Queue seperti Message Broker sebagai tempat aliran data, dan kita bisa fokus membuat Filter untuk memproses data tersebut.</li></ul><p><img alt="Pipeline Architecture" loading=lazy src=https://i.imgur.com/C4PQC3i.png></p><h2 id=topology-5>Topology<a hidden class=anchor aria-hidden=true href=#topology-5>#</a></h2><ul><li>Dalam Pipeline Architecture, fokus utama adalah proses Filter terhadap message.</li><li>Tidak ada aturan proses Filter apakah harus di dalam aplikasi yang sama atau berbeda, jadi tidak ada benar atau salah.</li><li>Filter biasanya adalah proses yang dilakukan dari mulai menerima input data, memproses data, dan berakhir dengan menghasilkan output data.</li></ul><h2 id=cloud-function>Cloud Function<a hidden class=anchor aria-hidden=true href=#cloud-function>#</a></h2><ul><li>Pipeline Architecture ini sekarang sangat populer di Cloud Provider seperti Google Cloud atau Amazon Web Service.</li><li>Cloud Provider tersebut sekarang memiliki fitur untuk Cloud Function, di mana bisa digunakan sebagai Filter dalam Pipeline Architecture.</li><li>Salah satu keuntungan menggunakan Cloud Function, kita hanya perlu bayar ketika Filter melakukan pemrosesan data.</li></ul><h2 id=data-pipeline>Data Pipeline<a hidden class=anchor aria-hidden=true href=#data-pipeline>#</a></h2><ul><li>Pipeline Architecture juga sering digunakan dalam melakukan pengolahan data, atau sering dikenal dengan nama Data Pipeline.</li><li>Dalam Data Pipeline, biasanya terdapat Source (sumber data), Destination (tujuan akhir data), dan juga Processing (pengolahan data).</li></ul><p><img alt="Data Pipeline" loading=lazy src=https://i.imgur.com/DnpaHg3.png></p><h2 id=contoh-7>Contoh<a hidden class=anchor aria-hidden=true href=#contoh-7>#</a></h2><ul><li>Kita ingin membuat laporan jumlah pengunjung harian website kita, di mana pada laporan tersebut, kita bisa melihat jumlah pengunjung berdasarkan negara pengunjung</li><li>Pada kasus ini kita bisa menggunakan Pipeline Architecture.</li><li>Dimulai dari setiap data kunjungan ke website kita, kita akan kirim sebagai event ke Message Broker, lalu kita akan buat filter, dari filter untuk mendeteksi ip address, filter untuk mendapatkan negara berdasarkan ip, dan filter untuk melakukan grouping berdasarkan negara.</li></ul><p><img alt="Contoh Pipeline Architecture" loading=lazy src=https://i.imgur.com/1ofWLgu.png></p><h2 id=pertimbangan-9>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-9>#</a></h2><ul><li>Pipeline Architecture merupakan arsitektur yang sangat cocok ketika kita ingin melakukan pemrosesan yang sangat panjang dan bertahap.</li><li>Pipeline Architecture bisa sangat lama melakukan pemrosesan, tergantung seberapa panjang Filter yang ada, Oleh karena itu tidak cocok untuk melakukan pekerjaan yang butuh waktu realtime.</li></ul><h1 id=space-based-architecture>Space-Based Architecture<a hidden class=anchor aria-hidden=true href=#space-based-architecture>#</a></h1><h2 id=triangle-shaped>Triangle-Shaped<a hidden class=anchor aria-hidden=true href=#triangle-shaped>#</a></h2><ul><li>Pada kasus tertentu, ada jenis aplikasi yang biasanya memiliki traffic pengunjung yang tidak terduga, misal seperti website flashsale, penjualan tiket atau bidding.</li><li>Arsitektur-arsitektur yang sebelumnya kita bahas, sebenarnya bisa kita gunakan untuk membuat jenis aplikasi tersebut, namun pada kasus tertentu, kadang akhirnya kita mendapatkan permasalahan triangle-shaped.</li></ul><p><img alt=Triangle-Shaped loading=lazy src=https://i.imgur.com/tyOQZcQ.png></p><h2 id=triangle-shaped-topology>Triangle-Shaped Topology<a hidden class=anchor aria-hidden=true href=#triangle-shaped-topology>#</a></h2><ul><li>Triangle-Shaped Topology adalah kondisi di mana kita melakukan scalability dengan cara menambah jumlah aplikasi ketika terjadi kelambatan di system kita.</li><li>Pada kasus ketika kita membuat web, untuk menambah jumlah web server biasanya sangat mudah, karena hanya menyediakan website user interface, selanjutnya biasanya kelambatan akan berpindah ke server Backend misal di RESTful API.</li><li>Selanjutnya biasanya kita akan menambah jumlah server RESTful API, namun tidak akan sebanyak Web Server, karena biasanya aplikasinya lebih berat dan membutuhkan resource lebih besar, selanjutnya kelambatan akan berpindah ke Database.</li><li>Pada kasus seperti ini, menambah server di database bukanlah hal yang mudah, tidak sefleksibel Web Server dan RESTful API, karena database adalah aplikasi stateful (menyimpan data).</li></ul><h2 id=space-based-architecture-1>Space-Based Architecture<a hidden class=anchor aria-hidden=true href=#space-based-architecture-1>#</a></h2><ul><li>Space-Based Architecture merupakan arsitektur yang di desain khusus untuk kasus seperti ini, di mana kita butuh scalability dan performa yang baik untuk aplikasi.</li><li>Space-Based Architecture menyelesaikan masalah ini, dengan cara menghapus database dari proses transaksi aplikasi, dan diganti dengan shared-memory (Data Grid).</li><li>High Scalability dicapai dengan cara semua aplikasi terkoneksi ke shared-memory (Data Grid) secara synchronous, dan secara asynchronous data di shared-memory akan di sync ke database,</li></ul><p><img alt="Space-Based Architecture" loading=lazy src=https://i.imgur.com/vA0NYSq.png></p><h2 id=topology-6>Topology<a hidden class=anchor aria-hidden=true href=#topology-6>#</a></h2><ul><li>Dalam Spaced-Based Architecture, aplikasi yang kita buat disebut dengan Processing Unit.</li><li>Dalam Processing Unit, terdapat logic aplikasi kita dan juga berisi In Memory Data Grid yang digunakan sebagai pengganti Database.</li><li>Biasanya terdapat Data Replication Engine yang digunakan untuk melakukan sinkronisasi seluruh data di In Memory Data Grid untuk semua Processing unit dengan dibantu Oleh Data Grid Cluster.</li><li>Jika kita mau, kita bisa secara async menyimpan perubahan yang terjadi di In Memory Data Grid ke Database.</li></ul><h2 id=contoh-data-grid>Contoh Data Grid<a hidden class=anchor aria-hidden=true href=#contoh-data-grid>#</a></h2><ul><li>Biasanya Data Grid tidak perlu dibuat secara manual Oleh pengembang aplikasi, sama seperti Database, kita bisa menggunakan aplikasi Data Grid yang sudah tersedia, contohnya.</li><li>Hazelcast.</li><li>Apache Ignite.</li><li>Oracle Coherence.</li><li>Dan lain-lain.</li></ul><h2 id=pertimbangan-10>Pertimbangan<a hidden class=anchor aria-hidden=true href=#pertimbangan-10>#</a></h2><ul><li>Spaced-Based Architecture merupakan solusi yang sangat kompleks untuk mencapai scalability yang sangat baik.</li><li>Namun walaupun solusi ini sangat baik, tapi kadang solusi ini bukan yang terbaik, kita harus melihat banyak pertimbangan ketika menggunakan arsitektur ini.</li><li>Contoh jika data kita terlalu besar, maka akan sulit menggunakan arsitektur ini, karena seluruh data harus dipindahkan ke memory, yang pasti butuh biaya yang sangat besar.</li><li>Karena kompleksitas dan mahalnya solusi ini, kita juga harus mempertimbangkan biaya yang harus dikeluarkan untuk menggunakan arsitektur ini.</li></ul><h1 id=penutup>Penutup<a hidden class=anchor aria-hidden=true href=#penutup>#</a></h1><ul><li>Software Architecture Patterns bukanlah solusi yang saklek di mana kita harus memilih salah satunya.</li><li>Kita bisa melakukan kombinasi beberapa Patterns yang memang sesuai dengan kebutuhan kita.</li><li>Misal kita bisa kombinasikan Microservices dan Event-Driven, atau Monolith dengan Layered, Microservices dengan Layered, dan lain-lain.</li></ul><h2 id=software-architecture-patterns-lainnya>Software Architecture Patterns Lainnya<a hidden class=anchor aria-hidden=true href=#software-architecture-patterns-lainnya>#</a></h2><ul><li>Kelas ini tidak membahas semua Software Architecture Patterns yang ada, hanya membahas yang sering digunakan.</li><li>Teknologi khususnya pada Software Design selalu berkembang dari waktu ke waktu, awal tahun 2000 belum banyak yang menggunakan Microservices, namun sekarang hampir semua perusahaan besar menggunakannya.</li><li>Masih banyak juga patterns yang belum dibahas, dan bisa dipelajari secara mandiri, seperti: Onion Architecture, Screaming Architecture, Event-Bus Architecture, dan masih banyak yang lainnya.</li></ul><hr><p>Sumber:<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/Ix09qfew6oA?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wewnumam.github.io/id/articles/welcome-to-artificial-intelligence/><span class=title>« Sebelumnya</span><br><span>Welcome to Artificial Intelligence</span>
</a><a class=next href=https://wewnumam.github.io/id/articles/learn-from-free-college-cs-courses/><span class=title>Selanjutnya »</span><br><span>Learn From Free College Cs Courses</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on x" href="https://x.com/intent/tweet/?text=Software%20Architecture%20Patterns&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f&amp;title=Software%20Architecture%20Patterns&amp;summary=Software%20Architecture%20Patterns&amp;source=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f&title=Software%20Architecture%20Patterns"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on whatsapp" href="https://api.whatsapp.com/send?text=Software%20Architecture%20Patterns%20-%20https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on telegram" href="https://telegram.me/share/url?text=Software%20Architecture%20Patterns&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Software Architecture Patterns on ycombinator" href="https://news.ycombinator.com/submitlink?t=Software%20Architecture%20Patterns&u=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fsoftware-architecture-patterns%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wewnumam.github.io/id/>Ahmad Adillaumam</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="salin";function s(){t.innerHTML="disalin!",setTimeout(()=>{t.innerHTML="salin"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>