<!doctype html><html lang=id dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes PKA | Ahmad Adillaumam</title><meta name=keywords content><meta name=description content="Pengenalan Kecerdasan Artifisial
Catatan tentang Perspektif dan Perkembangan KA
1. Tujuan yang Berbeda dalam AI


Orang memiliki tujuan yang berbeda dalam mempelajari AI:


Pemikiran vs. Perilaku: Apakah fokusnya pada bagaimana mesin berpikir atau bagaimana mesin bertindak?


Meniru manusia vs. Hasil optimal: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang paling optimal?




2. Model Standar AI


AI terutama berfokus pada tindakan rasional, yaitu membangun agen yang bertindak secara optimal."><meta name=author content="Ahmad Adillaumam"><link rel=canonical href=https://wewnumam.github.io/id/articles/notes-pka/><meta name=google-site-verification content="G-2KZ9LNNSKF"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wewnumam.github.io/favicon.png><link rel=icon type=image/png sizes=32x32 href=https://wewnumam.github.io/favicon.png><link rel=apple-touch-icon href=https://wewnumam.github.io/favicon.png><link rel=mask-icon href=https://wewnumam.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=id href=https://wewnumam.github.io/id/articles/notes-pka/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2KZ9LNNSKF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2KZ9LNNSKF")}</script><meta property="og:url" content="https://wewnumam.github.io/id/articles/notes-pka/"><meta property="og:site_name" content="Ahmad Adillaumam"><meta property="og:title" content="Notes PKA"><meta property="og:description" content="Pengenalan Kecerdasan Artifisial Catatan tentang Perspektif dan Perkembangan KA 1. Tujuan yang Berbeda dalam AI Orang memiliki tujuan yang berbeda dalam mempelajari AI:
Pemikiran vs. Perilaku: Apakah fokusnya pada bagaimana mesin berpikir atau bagaimana mesin bertindak?
Meniru manusia vs. Hasil optimal: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang paling optimal?
2. Model Standar AI AI terutama berfokus pada tindakan rasional, yaitu membangun agen yang bertindak secara optimal."><meta property="og:locale" content="id"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2025-10-07T12:28:24+07:00"><meta property="article:modified_time" content="2025-10-07T12:28:24+07:00"><meta property="og:image" content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph"><meta name=twitter:title content="Notes PKA"><meta name=twitter:description content="Pengenalan Kecerdasan Artifisial
Catatan tentang Perspektif dan Perkembangan KA
1. Tujuan yang Berbeda dalam AI


Orang memiliki tujuan yang berbeda dalam mempelajari AI:


Pemikiran vs. Perilaku: Apakah fokusnya pada bagaimana mesin berpikir atau bagaimana mesin bertindak?


Meniru manusia vs. Hasil optimal: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang paling optimal?




2. Model Standar AI


AI terutama berfokus pada tindakan rasional, yaitu membangun agen yang bertindak secara optimal."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://wewnumam.github.io/id/articles/"},{"@type":"ListItem","position":2,"name":"Notes PKA","item":"https://wewnumam.github.io/id/articles/notes-pka/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notes PKA","name":"Notes PKA","description":"Pengenalan Kecerdasan Artifisial Catatan tentang Perspektif dan Perkembangan KA 1. Tujuan yang Berbeda dalam AI Orang memiliki tujuan yang berbeda dalam mempelajari AI:\nPemikiran vs. Perilaku: Apakah fokusnya pada bagaimana mesin berpikir atau bagaimana mesin bertindak?\nMeniru manusia vs. Hasil optimal: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang paling optimal?\n2. Model Standar AI AI terutama berfokus pada tindakan rasional, yaitu membangun agen yang bertindak secara optimal.\n","keywords":[],"articleBody":"Pengenalan Kecerdasan Artifisial Catatan tentang Perspektif dan Perkembangan KA 1. Tujuan yang Berbeda dalam AI Orang memiliki tujuan yang berbeda dalam mempelajari AI:\nPemikiran vs. Perilaku: Apakah fokusnya pada bagaimana mesin berpikir atau bagaimana mesin bertindak?\nMeniru manusia vs. Hasil optimal: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang paling optimal?\n2. Model Standar AI AI terutama berfokus pada tindakan rasional, yaitu membangun agen yang bertindak secara optimal.\nAgen rasional adalah agen yang mengambil tindakan terbaik dalam suatu situasi.\n3. Penyempurnaan Model Standar Batasan komputasional: Rasionalitas sempurna sulit dicapai karena keterbatasan daya komputasi.\nTujuan berpusat pada manusia: AI seharusnya bertindak untuk memberikan manfaat bagi manusia, meskipun sering kali tidak pasti tentang apa sebenarnya yang diinginkan manusia.\n4. Kontribusi Dasar dari Berbagai Bidang Filsuf (sejak 400 SM): Mengusulkan bahwa pikiran bekerja seperti mesin yang memproses pengetahuan internal untuk menentukan tindakan.\nAhli matematika: Mengembangkan logika, probabilitas, serta dasar untuk memahami komputasi dan algoritma.\nEkonom: Memformalkan pengambilan keputusan dengan teori utilitas yang diharapkan (expected utility).\nAhli saraf (neurosaintis): Menemukan cara kerja otak serta persamaan dan perbedaannya dengan komputer.\nPsikolog: Memandang manusia dan hewan sebagai mesin pemroses informasi.\nAhli linguistik: Menunjukkan bahwa penggunaan bahasa dapat dijelaskan dengan model komputasional.\nInsinyur komputer: Membangun perangkat keras yang semakin kuat untuk memungkinkan aplikasi AI.\nInsinyur perangkat lunak: Membuat sistem AI lebih mudah digunakan.\nTeori kendali (control theory): Merancang sistem yang bertindak secara optimal berdasarkan umpan balik dari lingkungan; kini semakin banyak beririsan dengan AI.\n5. Perkembangan Historis AI Sejarah AI mengalami siklus keberhasilan, optimisme berlebihan, dan kemunduran (AI winter).\nSetiap masa membawa pendekatan baru yang kemudian disempurnakan.\n6. Evolusi Metode AI Dari logika Boolean → menuju penalaran probabilistik.\nDari pengetahuan buatan manusia → menuju pembelajaran mesin dari data.\nPergeseran ini meningkatkan kemampuan sistem AI dan memperkuat integrasinya dengan berbagai disiplin ilmu lain.\n7. Pertimbangan Etika dan Keamanan Penerapan AI di dunia nyata menimbulkan risiko dan konsekuensi etis.\nTantangan jangka panjang: Mengendalikan AI superinteligensi yang mungkin berkembang secara tidak terduga.\nMasalah ini menuntut perubahan cara pandang kita terhadap AI dan hubungannya dengan manusia.\nAgen Cerdas AI sebagai Desain Agen: Kecerdasan buatan dipandang sebagai ilmu merancang agen cerdas.\nDefinisi Agen: Agen adalah entitas yang dapat merasakan (perceive) dan bertindak (act) di dalam suatu lingkungan. Fungsi agen menentukan tindakan berdasarkan urutan persepsi yang diterimanya.\nUkuran Kinerja (Performance Measure): Menilai seberapa baik agen berperilaku di lingkungannya. Agen rasional memilih tindakan yang memaksimalkan nilai harapan ukuran kinerja.\nLingkungan Tugas (Task Environment): Meliputi ukuran kinerja, lingkungan eksternal, aktuator, dan sensor — harus dijabarkan secara lengkap sebelum merancang agen.\nJenis-jenis Lingkungan:\nObservable vs. Partially observable Single-agent vs. Multiagent Deterministic vs. Nondeterministic Episodic vs. Sequential Static vs. Dynamic Discrete vs. Continuous Known vs. Unknown Ketidakpastian Tujuan: Jika ukuran kinerja tidak jelas, agen bisa mengoptimalkan tujuan yang salah. Desain agen harus memperhitungkan ketidakpastian ini.\nProgram Agen: Mengimplementasikan fungsi agen. Desain program bergantung pada sifat lingkungan dan memengaruhi efisiensi, fleksibilitas, serta kepadatannya.\nJenis Agen:\nSimple Reflex Agent: Merespons langsung terhadap persepsi saat ini.\nModel-based Reflex Agent: Menyimpan keadaan internal untuk melacak aspek dunia yang tidak tampak.\nGoal-based Agent: Bertindak untuk mencapai tujuan.\nUtility-based Agent: Bertindak untuk memaksimalkan kebahagiaan atau utilitasnya sendiri.\nPembelajaran: Semua agen dapat meningkatkan kinerjanya melalui proses belajar.\nSearching Solution Ringkasan Bab ini membahas algoritma pencarian yang digunakan agen untuk memilih urutan tindakan dalam lingkungan yang episodic, single-agent, fully observable, deterministic, static, discrete, and completely known.\nAda kompromi antara waktu pencarian, kapasitas memori, dan kualitas solusi. Efisiensi meningkat jika digunakan fungsi heuristik atau solusi parsial yang telah dihitung sebelumnya.\nPoin-Poin Utama Perumusan Masalah – Masalah harus didefinisikan dengan jelas sebelum pencarian dimulai.\nKomponen:\nInitial state Set of actions Transition model Goal states Action cost function State Space – Direpresentasikan sebagai graf.\nJalur dari keadaan awal ke tujuan merupakan solusi. Kriteria Evaluasi Algoritma Pencarian:\nCompleteness Optimality (cost) Time complexity Space complexity Pencarian Tidak Terinformasi (Uninformed Search): Hanya menggunakan definisi masalah.\nBreadth-First Search: Mengembangkan node terdangkal; lengkap dan optimal untuk biaya satuan, tapi boros memori.\nUniform-Cost Search: Mengembangkan node dengan biaya terkecil; optimal untuk biaya umum.\nDepth-First Search: Mengembangkan node terdalam; tidak lengkap atau optimal, tapi hemat memori.\nDepth-Limited Search: Menambahkan batas kedalaman.\nIterative Deepening Search: DFS dengan batas kedalaman bertambah; lengkap, optimal untuk biaya satuan, ruang linear.\nBidirectional Search: Pencarian dari awal dan tujuan hingga bertemu.\nPencarian Terinformasi (Informed Search): Menggunakan fungsi heuristik h(n) yang memperkirakan biaya ke tujuan.\nGreedy Best-First Search: Mengembangkan node dengan h(n) terkecil; efisien tapi tidak optimal.\nA Search:* Mengembangkan node dengan f(n)=g(n)+h(n); lengkap dan optimal jika h(n) dapat diterima, tapi boros memori.\nBidirectional A:* Kadang lebih efisien dari A*.\nIDA:* Versi iteratif dari A*, mengatasi masalah ruang.\nRBFS dan SMA:* Pencarian optimal dengan batas memori.\nBeam Search: Membatasi ukuran frontier; tidak lengkap dan tidak optimal, tetapi cepat.\nWeighted A:* Mengarahkan pencarian lebih cepat ke tujuan dengan mengorbankan optimalitas.\nKualitas Heuristik – Menentukan kinerja pencarian.\nHeuristik yang baik dapat dibuat melalui:\nRelaksasi masalah Basis data pola (pattern database) Landmark Pembelajaran dari pengalaman Knowledge Representation Representasi pengetahuan skala besar memerlukan general-purpose ontology untuk mengorganisir dan menghubungkan berbagai domain pengetahuan spesifik.\nGeneral-purpose ontology harus mencakup berbagai jenis pengetahuan dan mampu menangani domain apa pun secara prinsip.\nMembangun ontology umum berskala besar masih menjadi tantangan besar, meskipun kerangka yang ada saat ini cukup kuat.\nSebuah upper ontology dapat dibangun berdasarkan categories dan event calculus, yang mencakup:\ncategories, subcategories, parts, structured objects, measurements, substances, events, time and space, change, dan beliefs. Natural kinds tidak dapat sepenuhnya didefinisikan dengan logika, tetapi sifat-sifatnya dapat direpresentasikan.\nActions, events, dan time dapat direpresentasikan menggunakan event calculus, yang memungkinkan agen menyusun urutan tindakan dan membuat inferensi logis tentang apa yang akan terjadi ketika tindakan tersebut dilakukan.\nSistem representasi khusus seperti semantic networks dan description logics membantu dalam mengorganisir hierarki kategori.\nInheritance merupakan bentuk inferensi penting yang memungkinkan sifat objek diturunkan dari keanggotaannya dalam kategori. Closed-world assumption dalam program logika menyediakan cara sederhana untuk menghindari spesifikasi informasi negatif yang berlebihan dan berfungsi sebagai aturan default.\nNonmonotonic logics seperti circumscription dan default logic dirancang untuk menangani default reasoning secara umum.\nTruth maintenance systems menangani pembaruan dan revisi pengetahuan dengan efisien.\nSulit untuk membangun ontology besar secara manual; knowledge extraction from text dapat mempermudah pekerjaan ini.\nPengolahan Bahasa Alami (NLP) Model bahasa probabilistik berbasis n-gram dapat mengekstrak banyak informasi dari bahasa dan bekerja dengan baik untuk tugas seperti language identification, spelling correction, sentiment analysis, genre classification, dan named-entity recognition.\nModel-model ini dapat memiliki jutaan fitur, sehingga preprocessing dan smoothing penting untuk mengurangi noise.\nDalam membangun sistem bahasa statistik, sebaiknya merancang model yang dapat memanfaatkan data dengan baik, meskipun tampak terlalu sederhana.\nWord embeddings memberikan representasi kata yang lebih kaya dan menggambarkan kemiripan antar kata.\nUntuk menangkap struktur hierarkis bahasa, phrase structure grammars (terutama context-free grammars) sangat berguna. Probabilistic context-free grammar (PCFG) dan dependency grammar banyak digunakan.\nKalimat dalam context-free language dapat di-parse dalam waktu O(n³) menggunakan chart parser seperti CYK algorithm, yang membutuhkan aturan tata bahasa dalam Chomsky Normal Form. Dengan sedikit penurunan akurasi, bahasa alami dapat di-parse dalam waktu O(n) menggunakan beam search atau shift-reduce parser.\nTreebank dapat menjadi sumber untuk mempelajari parameter PCFG.\nGrammar augmentation memudahkan penanganan subject–verb agreement, pronoun case, dan memungkinkan representasi informasi di tingkat kata, bukan hanya kategori sintaksis.\nSemantic interpretation juga dapat ditangani melalui augmented grammar, yang dapat dipelajari dari corpus berisi pertanyaan yang dipasangkan dengan logical form atau jawaban.\nBahasa alami sangat kompleks dan sulit sepenuhnya direpresentasikan dalam formal grammar.\nContoh Soal-Jawaban UTS Berikut jawaban singkat: tiap soal ditampilkan → jawaban ringkas.\n1. Pertanyaan: Anda sudah mengenal beberapa pengertian tentang Kecerdasan Artifisial (KA). Pada era industri 4.0 ini, menurut anda definisi KA yang mana yang cocok pada kondisi sekarang dan apa paradigma KA yang cocok.\nJawaban: Definisi yang cocok: KA adalah sistem/artifak komputer yang mampu mengamati lingkungan, belajar dari data/pengetahuan, membuat keputusan, dan bertindak untuk mencapai tujuan yang bermanfaat bagi manusia. Paradigma yang cocok: hybrid data-driven + simbolik — utamakan machine learning (deep learning) untuk persepsi \u0026 prediksi, dipadukan dengan komponen simbolik/penalaran (knowledge/rules, probabilistic models) untuk interpretabilitas, pengendalian kebijakan, dan keselamatan.\n2.a Pertanyaan: Deskripsikan sebuah contoh permainan game yang cocok diselesaikan dengan informed search.\nJawaban: Contoh: 8-puzzle (geser ubin 3×3 ke posisi tujuan). Informed search efektif karena ada heuristik (misal Manhattan distance) mempercepat pencarian solusi.\n2.b Pertanyaan: Buatlah state space, dan tuliskan algoritmanya untuk mendapatkan hasil akhir.\nJawaban (ringkas):\nState space: semua konfigurasi tata letak 9 ubin (termasuk kotak kosong).\nOperator: geser kotak kosong {up, down, left, right} bila legal.\nStart: konfigurasi awal; Goal: konfigurasi target.\nHeuristik: h(n) = jumlah Manhattan distance tiap ubin ke pos tujuan.\nAlgoritma: A*\nfunction A*(start, goal): open := {start} with f(start)=g(start)+h(start), g(start)=0 closed := {} while open not empty: n := node in open with smallest f if n == goal: return reconstruct_path(n) move n from open to closed for each successor s of n: tentative_g := g(n)+cost(n,s) if s in closed and tentative_g \u003e= g(s): continue if s not in open or tentative_g \u003c g(s): parent(s) := n g(s) := tentative_g f(s) := g(s)+h(s) add s to open 3.a Pertanyaan: Buatlah bagan sistem inferensi fuzzy, jelaskan masing-masing bagiannya.\nJawaban (ringkas): Bagan komponen:\nFuzzification — ubah input numerik ke derajat keanggotaan pada himpunan fuzzy. Knowledge / Rule base — kumpulan aturan IF–THEN (linguistik). Inference engine — evaluasi aturan, kombinasikan antecedent untuk menghasilkan fuzzy output (tingkat aktivasi rule). Aggregation — gabungkan kontribusi semua rule ke fungsi keanggotaan output fuzzy. Defuzzification — konversi output fuzzy ke nilai numerik tunggal (mis. centroid). 3.b Pertanyaan: Buatlah sebuah contoh sistem inferensi fuzzy yg menggunakan 3 input, 1 output diluar yg telah dibahas di kelas.\nJawaban (ringkas): Sistem irigasi pintar\nInput: SoilMoisture (kelembaban tanah), RainProb (probabilitas hujan), PlantNeed (kebutuhan air tanaman). Output: IrrigationDuration (durasi penyiraman dalam menit). 3.c Pertanyaan: Buatlah himpunan fuzzy untuk masing parameter.\nJawaban (ringkas): (semua rentang contoh 0–100 kecuali duration 0–60 menit)\nSoilMoisture: {Low (0–40), Medium (30–70), High (60–100)} (triangular/trapezoid). RainProb: {Low (0–30), Medium (20–70), High (60–100)}. PlantNeed: {Low (0–30), Normal (20–70), High (60–100)}. IrrigationDuration: {Short (0–15), Medium (10–30), Long (25–60)}. 3.d Pertanyaan: Buatlah 4 fuzzy rules yang mengandung paling tidak dua konklusi yang menjadi premis di rules yang lain.\nJawaban (ringkas): (gunakan variabel antara Urgency sebagai intermediate)\nR1: IF SoilMoisture IS Low THEN Urgency IS High. R2: IF RainProb IS High THEN Urgency IS Low. R3: IF Urgency IS High AND PlantNeed IS High THEN IrrigationDuration IS Long. R4: IF Urgency IS Medium OR RainProb IS Medium THEN IrrigationDuration IS Medium. (Keterangan: R1 \u0026 R2 menghasilkan Urgency — yang dipakai oleh R3/R4 sebagai premis.)\n4. Pertanyaan: Jelaskan bagaimana konsep Kecerdasan Artifisial serta berikan 5 contoh dan penjelasannya bidang aplikasi Kecerdasan Artifisial. Jelaskan dan terapkan metode inferensi yang anda ketahui untuk menghasilkan konklusi.\nJawaban (ringkas):\nKonsep AI: rekayasa sistem yang persepsi → representasi/pengetahuan → penalaran/decision → aksi, sering memakai probabilitas/statistik dan/atau aturan simbolik untuk mencapai tujuan.\n5 contoh aplikasi \u0026 penjelasan singkat:\nPengenalan gambar (Computer Vision) — deteksi objek/segmentasi untuk industri, keamanan. Sistem rekomendasi — menyarankan produk/musik dengan collaborative filtering / ML. Chatbot / NLP — pemrosesan bahasa alami untuk layanan pelanggan. Kendaraan otonom — integrasikan sensor + planning + control untuk mengemudi. Diagnosis medis berbasis AI — klasifikasi citra/risk scoring untuk membantu keputusan klinis. Metode inferensi (contoh aplikasi rule-based, forward chaining):\nContoh singkat: Sistem bantuan diagnostik (aturan):\nRule A: IF fever AND cough THEN suspect_infection. Rule B: IF suspect_infection AND chest_pain THEN suspect_pneumonia. Fact: fever = true, cough = true, chest_pain = true.\nForward chaining: dari Rule A → suspek_infection; dari suspek_infection + chest_pain + Rule B → suspek_pneumonia (konklusi). 5. Pertanyaan: Salah satu teknik penting dalam Kecerdasan Artifisial adalah searching. Sebutkan, jelaskan dan berilah contoh hal-hal yang berkaitan dengan proses searching tersebut! (5%)\nJawaban (ringkas):\nKomponen dasar: state space, initial state, goal test, operators, path cost, solusi (path). Uninformed search: tidak pakai heuristik. Contoh: BFS (lengkap, optimal jika cost=1), DFS (hemat memori, tidak optimal), Uniform-cost (optimal untuk biaya). Informed search (heuristic): pakai fungsi heuristik h(n). Contoh: Greedy best-first (cepat, tidak optimal), A* (optimal jika h admissible). Local search / hill-climbing: optimisasi tanpa eksplorasi penuh (contoh: simulated annealing, genetic algorithms). Contoh aplikasi: pathfinding di game (A*), puzzle solving (8-puzzle dengan A*), optimasi jadwal (genetic algorithms). 6. Diberikan pernyataan-pernyataan berikut…\nPernyataan:\nBudi suka semua jenis makanan. Apel adalah makanan. Ayam goreng adalah makanan. Sesuatu yang dimakan dan tidak membuat mati adalah makanan. Johan makan kacang dan masih hidup. Susi makan setiap yang dimakan Johan. 6.a Pertanyaan: Tuliskan kalimat-kalimat tersebut dalam logika predikat!\nJawaban (ringkas): (predikat: Food(x), Likes(budi,x), Eats(person,x), AliveAfterEating(person,x))\n∀x (Food(x) → Likes(Budi,x)). Food(apel). Food(ayam_goreng). ∀y∀z (Eats(y,z) ∧ AliveAfterEating(y,z) → Food(z)). Eats(Johan,kacang) ∧ AliveAfterEating(Johan,kacang). ∀x (Eats(Johan,x) → Eats(Susi,x)). 6.b Pertanyaan: Dengan menggunakan teknik resolusi, tunjukkan bahwa Budi suka kacang!\nJawaban (ringkas, langkah resolusi):\nDari (5) dan (4): Eats(Johan,kacang) ∧ AliveAfterEating(Johan,kacang) ⇒ Food(kacang). (instansiasi) Dari (1) dan Food(kacang) ⇒ Likes(Budi,kacang). (modus ponens / resolusi)\nJadi: Likes(Budi,kacang). (terbukti) 6.c Pertanyaan: Gunakan teknik resolusi untuk menjawab pertanyaan: “Apa makanan yang dimakan Susi.”\nJawaban (ringkas):\nDari (5): Eats(Johan,kacang). Dari (6): Eats(Johan,kacang) → Eats(Susi,kacang). Jadi Susi makan kacang. Umum: Susi makan semua yang Johan makan (∀x Eats(Johan,x) → Eats(Susi,x)), jadi Susi makan setiap item yang Johan makan (di sini: kacang). Flash Card Kartu Flash — Pengenalan Kecerdasan Buatan (1–10) Q: Apa definisi singkat Kecerdasan Buatan (AI)?\nA: Sistem komputer yang mengamati lingkungan, memproses informasi, belajar, dan bertindak untuk mencapai tujuan tertentu.\nQ: Sebutkan dua pendekatan utama dalam AI.\nA: Pendekatan simbolik (aturan/logika) dan pendekatan statistik/pembelajaran (ML/DL).\nQ: Apa yang dimaksud agen rasional?\nA: Agen yang memilih aksi untuk memaksimalkan expected performance berdasarkan persepsi dan pengetahuan.\nQ: Mengapa etika penting dalam pengembangan AI?\nA: Karena AI dapat mempengaruhi keselamatan, privasi, fairness, dan keputusan bernilai pada manusia.\nQ: Apa perbedaan antara AI kuat (strong AI) dan AI lemah (weak AI)?\nA: Weak AI fokus tugas spesifik; strong AI berarti kemampuan kognitif umum setara manusia.\nQ: Sebutkan satu contoh aplikasi AI di kehidupan sehari-hari.\nA: Rekomendasi produk, asisten virtual, deteksi wajah, atau kendaraan otonom.\nQ: Mengapa hybrid (simbolik + statistik) sering digunakan?\nA: Untuk memanfaatkan interpretabilitas aturan sekaligus kekuatan generalisasi data-driven.\nQ: Apa arti “bias data” pada AI?\nA: Ketidakseimbangan atau pola buruk di data yang menyebabkan model membuat keputusan tidak adil.\nQ: Apa tujuan evaluasi model AI?\nA: Menilai kinerja, generalisasi, keandalan, dan kecocokan model untuk tugas nyata.\nQ: Sebutkan satu batasan penting AI modern.\nA: Kebutuhan data banyak; kadang sulit interpretasi (black-box).\nKartu Flash — Agen Cerdas (11–20) Q: Apa fungsi agen?\nA: Mapping dari percept (input sensor) ke aksi (action).\nQ: Jenis agen sederhana pertama yang sering dibahas?\nA: Simple reflex agent (respon berdasarkan kondisi sekarang).\nQ: Kapan simple reflex agent gagal?\nA: Saat lingkungan partial observable atau memerlukan memori/history.\nQ: Apa itu model-based agent?\nA: Agen yang menyimpan state internal/model lingkungan untuk membuat keputusan.\nQ: Bedakan goal-based dan utility-based agent.\nA: Goal-based berorientasi mencapai goal; utility-based memaksimalkan nilai utilitas yang mengukur preferensi.\nQ: Sebutkan dua dimensi karakter lingkungan agen.\nA: Observable vs partially observable; deterministic vs nondeterministic.\nQ: Apa arti environment episodic vs sequential?\nA: Episodic: setiap episode independen; sequential: keputusan sekarang mempengaruhi masa depan.\nQ: Apa tantangan pada multi-agent environment?\nA: Koordinasi, kompetisi, komunikasi, dan ketidakpastian perilaku agen lain.\nQ: Mengapa representasi state penting pada agen?\nA: Karena menentukan apa yang agen ketahui dan bagaimana dia merencanakan aksi.\nQ: Contoh nyata utility-based agent.\nA: Agen trading yang memaksimalkan expected return dengan penalti risiko.\nKartu Flash — Searching / Pencarian Solusi (21–30) Q: Apa komponen utama formulasi masalah pencarian?\nA: Initial state, actions, transition model, goal test, cost function.\nQ: Apa tujuan algoritma search?\nA: Menemukan urutan aksi dari initial state ke goal state.\nQ: Kapan BFS lebih cocok daripada DFS?\nA: Saat solusi paling dangkal dicari dan ruang status terdiskret/sedang.\nQ: Apa kelebihan dan kekurangan DFS?\nA: Kelebihan memori rendah; kekurangan bisa tidak lengkap dan terjebak di cabang tak hingga.\nQ: Apa itu Uniform Cost Search (UCS)?\nA: Search yang memilih node dengan biaya kumulatif terkecil (optimal untuk biaya non-negatif).\nQ: Rumus utama A* dan maknanya.\nA: f(n)=g(n)+h(n). g biaya dari start ke n; h estimasi biaya n→goal.\nQ: Apa itu heuristik admissible?\nA: Heuristik yang tidak pernah melebih-lebihkan biaya sebenarnya ke goal (underestimate).\nQ: Mengapa konsistensi heuristik penting?\nA: Konsisten (monotonic) memastikan f tidak menurun dan membuat A* lebih efisien (tidak perlu reopen node).\nQ: Bagaimana membuat heuristik dari relaksasi masalah?\nA: Hilangkan beberapa constraint sehingga solusi relaksasi mudah dihitung → gunakan biaya relaksasi sebagai h.\nQ: Apa trade-off antara beam search dan A*?\nA: Beam lebih hemat memori tapi tidak lengkap/optimal; A* lengkap/optimal dengan heuristik admissible tapi memori besar.\nKartu Flash — Knowledge Representation (31–40) Q: Apa tujuan Knowledge Representation (KR)?\nA: Menyimpan pengetahuan sehingga mesin dapat melakukan inferensi dan membuat keputusan.\nQ: Bedakan propositional vs predicate logic.\nA: Propositional: atom tanpa argumen; predicate: fungsi/predikat dengan variabel → ekspresivitas lebih tinggi.\nQ: Apa itu ontology dalam KR?\nA: Model konsep dan relasi domain untuk komunikasi dan interoperabilitas pengetahuan.\nQ: Fungsi semantic network?\nA: Merepresentasikan konsep sebagai node dan relasi sebagai edge untuk inferensi berbasis jaringan.\nQ: Apa itu nonmonotonic reasoning?\nA: Penalaran di mana menambah informasi baru dapat mengubah kesimpulan sebelumnya (default assumptions).\nQ: Untuk apa truth maintenance system (TMS)?\nA: Melacak justifikasi untuk fakta sehingga dapat retract (membatalkan) dengan konsisten.\nQ: Kapan description logic biasa dipakai?\nA: Untuk ontologies dan reasoning tentang kelas, subclass, dan keterbatasan (mis. OWL).\nQ: Apa role event calculus?\nA: Merepresentasikan events, waktu, dan efeknya pada status world untuk reasoning temporal.\nQ: Apa tantangan utama saat membangun knowledge base dari teks?\nA: Ambiguitas bahasa, inkonsistensi, pengenalan entitas, dan skala data.\nQ: Sebutkan satu metode untuk menangani default assumptions.\nA: Default logic atau circumscription untuk mengekspresikan asumsi “kecuali terbukti sebaliknya”.\nKartu Flash — NLP (Pengolahan Bahasa Alami) (41–50) Q: Apa itu model n-gram?\nA: Model probabilistik yang memprediksi kata berikutnya berdasarkan (n−1) kata sebelumnya.\nQ: Kenapa smoothing diperlukan pada n-gram?\nA: Untuk memberi probabilitas pada n-gram yang tidak muncul di data training (menghindari nol).\nQ: Sebutkan satu teknik smoothing.\nA: Laplace smoothing (add-one) atau Kneser-Ney.\nQ: Apa itu PCFG?\nA: Probabilistic Context-Free Grammar — grammar kontekstual dengan probabilitas untuk produksi aturan.\nQ: Untuk apa algoritma CYK dipakai? dan kompleksitasnya?\nA: Parsing dengan grammar CNF; kompleksitas O(n³) (n = panjang kalimat).\nQ: Perbedaan parsing dependensi dan parsing konstituen?\nA: Dependensi fokus relasi antar kata; konstituen fokus struktur frasa dan pohon konstituen.\nQ: Apa itu word embedding?\nA: Representasi vektor kata yang menangkap makna/kemiripan semantik (mis. word2vec).\nQ: Bagaimana embeddings membantu task NLP?\nA: Menyediakan fitur kontinu yang menangkap hubungan semantik sehingga model ML lebih efektif.\nQ: Sebutkan satu aplikasi sederhana model n-gram.\nA: Language identification, spelling correction, atau predictive text sederhana.\nQ: Mengapa treebanks penting untuk NLP?\nA: Sebagai data beranotasi untuk melatih parser, POS tagger, dan model sintaksis lainnya.\n","wordCount":"3080","inLanguage":"id","image":"https://wewnumam.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph","datePublished":"2025-10-07T12:28:24+07:00","dateModified":"2025-10-07T12:28:24+07:00","author":{"@type":"Person","name":"Ahmad Adillaumam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wewnumam.github.io/id/articles/notes-pka/"},"publisher":{"@type":"Organization","name":"Ahmad Adillaumam","logo":{"@type":"ImageObject","url":"https://wewnumam.github.io/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wewnumam.github.io/id/ accesskey=h title="Ahmad Adillaumam (Alt + H)"><img src=https://wewnumam.github.io/favicon.png alt aria-label=logo height=35>Ahmad Adillaumam</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wewnumam.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://wewnumam.github.io/id/archives/ title=Arsip><span>Arsip</span></a></li><li><a href=https://wewnumam.github.io/id/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://wewnumam.github.io/id/search/ title="Telusuri (Alt + /)" accesskey=/><span>Telusuri</span></a></li><li><a href=https://wewnumam.github.io/id/about/ title="Tentang Saya"><span>Tentang Saya</span></a></li><li><a href=https://github.com/wewnumam/gtstmm-gamedev-roadmap title="Gamedev Roadmap"><span>Gamedev Roadmap</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://gist.github.com/wewnumam/e0fa4b6e659ad5d08e5a373198909ddb title=Bookmarks><span>Bookmarks</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wewnumam.github.io/id/>Beranda</a>&nbsp;»&nbsp;<a href=https://wewnumam.github.io/id/articles/>Articles</a></div><h1 class="post-title entry-hint-parent">Notes PKA</h1><div class=post-meta><span title='2025-10-07 12:28:24 +0700 +0700'>7 Oktober 2025</span>&nbsp;·&nbsp;15 menit&nbsp;·&nbsp;3080 kata&nbsp;·&nbsp;Ahmad Adillaumam&nbsp;|&nbsp;<a href=https://github.com/wewnumam/wewnumam.github.io/tree/main/content/articles/notes-pka.id.md rel="noopener noreferrer" target=_blank>Usulkan Perubahan</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Daftar isi</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#pengenalan-kecerdasan-artifisial>Pengenalan Kecerdasan Artifisial</a><ul><li><a href=#catatan-tentang-perspektif-dan-perkembangan-ka>Catatan tentang Perspektif dan Perkembangan KA</a></li></ul></li><li><a href=#agen-cerdas>Agen Cerdas</a></li><li><a href=#searching-solution>Searching Solution</a><ul><li><a href=#ringkasan><strong>Ringkasan</strong></a></li><li><a href=#poin-poin-utama><strong>Poin-Poin Utama</strong></a></li></ul></li><li><a href=#knowledge-representation>Knowledge Representation</a></li><li><a href=#pengolahan-bahasa-alami-nlp>Pengolahan Bahasa Alami (NLP)</a></li><li><a href=#contoh-soal-jawaban-uts>Contoh Soal-Jawaban UTS</a></li><li><a href=#flash-card>Flash Card</a><ul><li><a href=#kartu-flash--pengenalan-kecerdasan-buatan-110>Kartu Flash — Pengenalan Kecerdasan Buatan (1–10)</a></li><li><a href=#kartu-flash--agen-cerdas-1120>Kartu Flash — Agen Cerdas (11–20)</a></li><li><a href=#kartu-flash--searching--pencarian-solusi-2130>Kartu Flash — Searching / Pencarian Solusi (21–30)</a></li><li><a href=#kartu-flash--knowledge-representation-3140>Kartu Flash — Knowledge Representation (31–40)</a></li><li><a href=#kartu-flash--nlp-pengolahan-bahasa-alami-4150>Kartu Flash — NLP (Pengolahan Bahasa Alami) (41–50)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=pengenalan-kecerdasan-artifisial>Pengenalan Kecerdasan Artifisial<a hidden class=anchor aria-hidden=true href=#pengenalan-kecerdasan-artifisial>#</a></h2><h3 id=catatan-tentang-perspektif-dan-perkembangan-ka>Catatan tentang Perspektif dan Perkembangan KA<a hidden class=anchor aria-hidden=true href=#catatan-tentang-perspektif-dan-perkembangan-ka>#</a></h3><h4 id=1-tujuan-yang-berbeda-dalam-ai><strong>1. Tujuan yang Berbeda dalam AI</strong><a hidden class=anchor aria-hidden=true href=#1-tujuan-yang-berbeda-dalam-ai>#</a></h4><ul><li><p>Orang memiliki tujuan yang berbeda dalam mempelajari AI:</p><ul><li><p><strong>Pemikiran vs. Perilaku</strong>: Apakah fokusnya pada bagaimana mesin <em>berpikir</em> atau bagaimana mesin <em>bertindak</em>?</p></li><li><p><strong>Meniru manusia vs. Hasil optimal</strong>: Apakah AI harus meniru kecerdasan manusia atau mencapai hasil yang <em>paling optimal</em>?</p></li></ul></li></ul><h4 id=2-model-standar-ai><strong>2. Model Standar AI</strong><a hidden class=anchor aria-hidden=true href=#2-model-standar-ai>#</a></h4><ul><li><p>AI terutama berfokus pada <strong>tindakan rasional</strong>, yaitu membangun agen yang bertindak secara optimal.</p></li><li><p><strong>Agen rasional</strong> adalah agen yang mengambil tindakan terbaik dalam suatu situasi.</p></li></ul><h4 id=3-penyempurnaan-model-standar><strong>3. Penyempurnaan Model Standar</strong><a hidden class=anchor aria-hidden=true href=#3-penyempurnaan-model-standar>#</a></h4><ul><li><p><strong>Batasan komputasional</strong>: Rasionalitas sempurna sulit dicapai karena keterbatasan daya komputasi.</p></li><li><p><strong>Tujuan berpusat pada manusia</strong>: AI seharusnya bertindak untuk <em>memberikan manfaat bagi manusia</em>, meskipun sering kali tidak pasti tentang apa sebenarnya yang diinginkan manusia.</p></li></ul><h4 id=4-kontribusi-dasar-dari-berbagai-bidang><strong>4. Kontribusi Dasar dari Berbagai Bidang</strong><a hidden class=anchor aria-hidden=true href=#4-kontribusi-dasar-dari-berbagai-bidang>#</a></h4><ul><li><p><strong>Filsuf</strong> (sejak 400 SM): Mengusulkan bahwa pikiran bekerja seperti mesin yang memproses pengetahuan internal untuk menentukan tindakan.</p></li><li><p><strong>Ahli matematika</strong>: Mengembangkan logika, probabilitas, serta dasar untuk memahami komputasi dan algoritma.</p></li><li><p><strong>Ekonom</strong>: Memformalkan <strong>pengambilan keputusan</strong> dengan teori <em>utilitas yang diharapkan</em> (expected utility).</p></li><li><p><strong>Ahli saraf (neurosaintis)</strong>: Menemukan cara kerja otak serta persamaan dan perbedaannya dengan komputer.</p></li><li><p><strong>Psikolog</strong>: Memandang manusia dan hewan sebagai <strong>mesin pemroses informasi</strong>.</p></li><li><p><strong>Ahli linguistik</strong>: Menunjukkan bahwa <strong>penggunaan bahasa</strong> dapat dijelaskan dengan model komputasional.</p></li><li><p><strong>Insinyur komputer</strong>: Membangun <strong>perangkat keras</strong> yang semakin kuat untuk memungkinkan aplikasi AI.</p></li><li><p><strong>Insinyur perangkat lunak</strong>: Membuat sistem AI lebih <strong>mudah digunakan</strong>.</p></li><li><p><strong>Teori kendali (control theory)</strong>: Merancang sistem yang bertindak <strong>secara optimal berdasarkan umpan balik</strong> dari lingkungan; kini semakin banyak beririsan dengan AI.</p></li></ul><h4 id=5-perkembangan-historis-ai><strong>5. Perkembangan Historis AI</strong><a hidden class=anchor aria-hidden=true href=#5-perkembangan-historis-ai>#</a></h4><ul><li><p>Sejarah AI mengalami <strong>siklus keberhasilan, optimisme berlebihan, dan kemunduran</strong> (AI winter).</p></li><li><p>Setiap masa membawa <strong>pendekatan baru</strong> yang kemudian disempurnakan.</p></li></ul><h4 id=6-evolusi-metode-ai><strong>6. Evolusi Metode AI</strong><a hidden class=anchor aria-hidden=true href=#6-evolusi-metode-ai>#</a></h4><ul><li><p>Dari <strong>logika Boolean</strong> → menuju <strong>penalaran probabilistik</strong>.</p></li><li><p>Dari <strong>pengetahuan buatan manusia</strong> → menuju <strong>pembelajaran mesin dari data</strong>.</p></li><li><p>Pergeseran ini meningkatkan kemampuan sistem AI dan memperkuat integrasinya dengan berbagai disiplin ilmu lain.</p></li></ul><h4 id=7-pertimbangan-etika-dan-keamanan><strong>7. Pertimbangan Etika dan Keamanan</strong><a hidden class=anchor aria-hidden=true href=#7-pertimbangan-etika-dan-keamanan>#</a></h4><ul><li><p>Penerapan AI di dunia nyata menimbulkan <strong>risiko dan konsekuensi etis</strong>.</p></li><li><p>Tantangan jangka panjang: <strong>Mengendalikan AI superinteligensi</strong> yang mungkin berkembang secara tidak terduga.</p></li><li><p>Masalah ini menuntut <strong>perubahan cara pandang kita terhadap AI</strong> dan hubungannya dengan manusia.</p></li></ul><hr><h2 id=agen-cerdas>Agen Cerdas<a hidden class=anchor aria-hidden=true href=#agen-cerdas>#</a></h2><ul><li><p><strong>AI sebagai Desain Agen</strong>: Kecerdasan buatan dipandang sebagai ilmu merancang agen cerdas.</p></li><li><p><strong>Definisi Agen</strong>: Agen adalah entitas yang dapat <em>merasakan (perceive)</em> dan <em>bertindak (act)</em> di dalam suatu lingkungan. <em>Fungsi agen</em> menentukan tindakan berdasarkan urutan persepsi yang diterimanya.</p></li><li><p><strong>Ukuran Kinerja (Performance Measure)</strong>: Menilai seberapa baik agen berperilaku di lingkungannya. Agen <em>rasional</em> memilih tindakan yang memaksimalkan nilai harapan ukuran kinerja.</p></li><li><p><strong>Lingkungan Tugas (Task Environment)</strong>: Meliputi ukuran kinerja, lingkungan eksternal, aktuator, dan sensor — harus dijabarkan secara lengkap sebelum merancang agen.</p></li><li><p><strong>Jenis-jenis Lingkungan</strong>:</p><ul><li>Observable vs. Partially observable</li><li>Single-agent vs. Multiagent</li><li>Deterministic vs. Nondeterministic</li><li>Episodic vs. Sequential</li><li>Static vs. Dynamic</li><li>Discrete vs. Continuous</li><li>Known vs. Unknown</li></ul></li><li><p><strong>Ketidakpastian Tujuan</strong>: Jika ukuran kinerja tidak jelas, agen bisa mengoptimalkan tujuan yang salah. Desain agen harus memperhitungkan ketidakpastian ini.</p></li><li><p><strong>Program Agen</strong>: Mengimplementasikan fungsi agen. Desain program bergantung pada sifat lingkungan dan memengaruhi efisiensi, fleksibilitas, serta kepadatannya.</p></li><li><p><strong>Jenis Agen</strong>:</p><ul><li><p><em>Simple Reflex Agent</em>: Merespons langsung terhadap persepsi saat ini.</p></li><li><p><em>Model-based Reflex Agent</em>: Menyimpan keadaan internal untuk melacak aspek dunia yang tidak tampak.</p></li><li><p><em>Goal-based Agent</em>: Bertindak untuk mencapai tujuan.</p></li><li><p><em>Utility-based Agent</em>: Bertindak untuk memaksimalkan kebahagiaan atau utilitasnya sendiri.</p></li></ul></li><li><p><strong>Pembelajaran</strong>: Semua agen dapat meningkatkan kinerjanya melalui proses belajar.</p></li></ul><hr><h2 id=searching-solution>Searching Solution<a hidden class=anchor aria-hidden=true href=#searching-solution>#</a></h2><h3 id=ringkasan><strong>Ringkasan</strong><a hidden class=anchor aria-hidden=true href=#ringkasan>#</a></h3><p>Bab ini membahas <strong>algoritma pencarian</strong> yang digunakan agen untuk memilih urutan tindakan dalam lingkungan yang <strong>episodic, single-agent, fully observable, deterministic, static, discrete, and completely known</strong>.<br>Ada kompromi antara <strong>waktu pencarian, kapasitas memori, dan kualitas solusi</strong>. Efisiensi meningkat jika digunakan <strong>fungsi heuristik</strong> atau <strong>solusi parsial yang telah dihitung sebelumnya</strong>.</p><h3 id=poin-poin-utama><strong>Poin-Poin Utama</strong><a hidden class=anchor aria-hidden=true href=#poin-poin-utama>#</a></h3><ol><li><p><strong>Perumusan Masalah</strong> – Masalah harus didefinisikan dengan jelas sebelum pencarian dimulai.<br>Komponen:</p><ul><li>Initial state</li><li>Set of actions</li><li>Transition model</li><li>Goal states</li><li>Action cost function</li></ul></li><li><p><strong>State Space</strong> – Direpresentasikan sebagai graf.</p><ul><li>Jalur dari keadaan awal ke tujuan merupakan solusi.</li></ul></li><li><p><strong>Kriteria Evaluasi Algoritma Pencarian:</strong></p><ul><li>Completeness</li><li>Optimality (cost)</li><li>Time complexity</li><li>Space complexity</li></ul></li><li><p><strong>Pencarian Tidak Terinformasi (Uninformed Search):</strong> Hanya menggunakan definisi masalah.</p><ul><li><p><strong>Breadth-First Search:</strong> Mengembangkan node terdangkal; lengkap dan optimal untuk biaya satuan, tapi boros memori.</p></li><li><p><strong>Uniform-Cost Search:</strong> Mengembangkan node dengan biaya terkecil; optimal untuk biaya umum.</p></li><li><p><strong>Depth-First Search:</strong> Mengembangkan node terdalam; tidak lengkap atau optimal, tapi hemat memori.</p></li><li><p><strong>Depth-Limited Search:</strong> Menambahkan batas kedalaman.</p></li><li><p><strong>Iterative Deepening Search:</strong> DFS dengan batas kedalaman bertambah; lengkap, optimal untuk biaya satuan, ruang linear.</p></li><li><p><strong>Bidirectional Search:</strong> Pencarian dari awal dan tujuan hingga bertemu.</p></li></ul></li><li><p><strong>Pencarian Terinformasi (Informed Search):</strong> Menggunakan <strong>fungsi heuristik h(n)</strong> yang memperkirakan biaya ke tujuan.</p><ul><li><p><strong>Greedy Best-First Search:</strong> Mengembangkan node dengan h(n) terkecil; efisien tapi tidak optimal.</p></li><li><p><em><em>A</em> Search:</em>* Mengembangkan node dengan f(n)=g(n)+h(n); lengkap dan optimal jika h(n) dapat diterima, tapi boros memori.</p></li><li><p><em><em>Bidirectional A</em>:</em>* Kadang lebih efisien dari A*.</p></li><li><p><em><em>IDA</em>:</em>* Versi iteratif dari A*, mengatasi masalah ruang.</p></li><li><p><em><em>RBFS dan SMA</em>:</em>* Pencarian optimal dengan batas memori.</p></li><li><p><strong>Beam Search:</strong> Membatasi ukuran frontier; tidak lengkap dan tidak optimal, tetapi cepat.</p></li><li><p><em><em>Weighted A</em>:</em>* Mengarahkan pencarian lebih cepat ke tujuan dengan mengorbankan optimalitas.</p></li></ul></li><li><p><strong>Kualitas Heuristik</strong> – Menentukan kinerja pencarian.<br>Heuristik yang baik dapat dibuat melalui:</p><ul><li>Relaksasi masalah</li><li>Basis data pola (pattern database)</li><li>Landmark</li><li>Pembelajaran dari pengalaman</li></ul></li></ol><hr><h2 id=knowledge-representation>Knowledge Representation<a hidden class=anchor aria-hidden=true href=#knowledge-representation>#</a></h2><ul><li><p>Representasi pengetahuan skala besar memerlukan <strong>general-purpose ontology</strong> untuk mengorganisir dan menghubungkan berbagai domain pengetahuan spesifik.</p></li><li><p><strong>General-purpose ontology</strong> harus mencakup berbagai jenis pengetahuan dan mampu menangani domain apa pun secara prinsip.</p></li><li><p>Membangun ontology umum berskala besar masih menjadi tantangan besar, meskipun kerangka yang ada saat ini cukup kuat.</p></li><li><p>Sebuah <strong>upper ontology</strong> dapat dibangun berdasarkan <strong>categories</strong> dan <strong>event calculus</strong>, yang mencakup:</p><ul><li>categories, subcategories, parts, structured objects, measurements, substances, events, time and space, change, dan beliefs.</li></ul></li><li><p><strong>Natural kinds</strong> tidak dapat sepenuhnya didefinisikan dengan logika, tetapi sifat-sifatnya dapat direpresentasikan.</p></li><li><p><strong>Actions</strong>, <strong>events</strong>, dan <strong>time</strong> dapat direpresentasikan menggunakan <strong>event calculus</strong>, yang memungkinkan agen menyusun urutan tindakan dan membuat inferensi logis tentang apa yang akan terjadi ketika tindakan tersebut dilakukan.</p></li><li><p>Sistem representasi khusus seperti <strong>semantic networks</strong> dan <strong>description logics</strong> membantu dalam mengorganisir hierarki kategori.</p><ul><li><strong>Inheritance</strong> merupakan bentuk inferensi penting yang memungkinkan sifat objek diturunkan dari keanggotaannya dalam kategori.</li></ul></li><li><p><strong>Closed-world assumption</strong> dalam program logika menyediakan cara sederhana untuk menghindari spesifikasi informasi negatif yang berlebihan dan berfungsi sebagai aturan default.</p></li><li><p><strong>Nonmonotonic logics</strong> seperti <strong>circumscription</strong> dan <strong>default logic</strong> dirancang untuk menangani <strong>default reasoning</strong> secara umum.</p></li><li><p><strong>Truth maintenance systems</strong> menangani pembaruan dan revisi pengetahuan dengan efisien.</p></li><li><p>Sulit untuk membangun ontology besar secara manual; <strong>knowledge extraction from text</strong> dapat mempermudah pekerjaan ini.</p></li></ul><hr><h2 id=pengolahan-bahasa-alami-nlp>Pengolahan Bahasa Alami (NLP)<a hidden class=anchor aria-hidden=true href=#pengolahan-bahasa-alami-nlp>#</a></h2><ul><li><p><strong>Model bahasa probabilistik</strong> berbasis <strong>n-gram</strong> dapat mengekstrak banyak informasi dari bahasa dan bekerja dengan baik untuk tugas seperti <strong>language identification</strong>, <strong>spelling correction</strong>, <strong>sentiment analysis</strong>, <strong>genre classification</strong>, dan <strong>named-entity recognition</strong>.</p></li><li><p>Model-model ini dapat memiliki <strong>jutaan fitur</strong>, sehingga <strong>preprocessing</strong> dan <strong>smoothing</strong> penting untuk mengurangi noise.</p></li><li><p>Dalam membangun <strong>sistem bahasa statistik</strong>, sebaiknya merancang model yang dapat memanfaatkan data dengan baik, meskipun tampak <strong>terlalu sederhana</strong>.</p></li><li><p><strong>Word embeddings</strong> memberikan representasi kata yang lebih kaya dan menggambarkan <strong>kemiripan antar kata</strong>.</p></li><li><p>Untuk menangkap <strong>struktur hierarkis bahasa</strong>, <strong>phrase structure grammars</strong> (terutama <strong>context-free grammars</strong>) sangat berguna. <strong>Probabilistic context-free grammar (PCFG)</strong> dan <strong>dependency grammar</strong> banyak digunakan.</p></li><li><p>Kalimat dalam <strong>context-free language</strong> dapat di-<strong>parse</strong> dalam waktu <strong>O(n³)</strong> menggunakan <strong>chart parser</strong> seperti <strong>CYK algorithm</strong>, yang membutuhkan aturan tata bahasa dalam <strong>Chomsky Normal Form</strong>. Dengan sedikit penurunan akurasi, bahasa alami dapat di-<strong>parse</strong> dalam waktu <strong>O(n)</strong> menggunakan <strong>beam search</strong> atau <strong>shift-reduce parser</strong>.</p></li><li><p><strong>Treebank</strong> dapat menjadi sumber untuk mempelajari parameter <strong>PCFG</strong>.</p></li><li><p><strong>Grammar augmentation</strong> memudahkan penanganan <strong>subject–verb agreement</strong>, <strong>pronoun case</strong>, dan memungkinkan representasi informasi di tingkat <strong>kata</strong>, bukan hanya <strong>kategori sintaksis</strong>.</p></li><li><p><strong>Semantic interpretation</strong> juga dapat ditangani melalui <strong>augmented grammar</strong>, yang dapat dipelajari dari <strong>corpus</strong> berisi pertanyaan yang dipasangkan dengan <strong>logical form</strong> atau <strong>jawaban</strong>.</p></li><li><p><strong>Bahasa alami</strong> sangat <strong>kompleks</strong> dan sulit sepenuhnya direpresentasikan dalam <strong>formal grammar</strong>.</p></li></ul><hr><h2 id=contoh-soal-jawaban-uts>Contoh Soal-Jawaban UTS<a hidden class=anchor aria-hidden=true href=#contoh-soal-jawaban-uts>#</a></h2><p>Berikut jawaban singkat: tiap soal ditampilkan → jawaban ringkas.</p><p><strong>1. Pertanyaan:</strong> Anda sudah mengenal beberapa pengertian tentang Kecerdasan Artifisial (KA). Pada era industri 4.0 ini, menurut anda definisi KA yang mana yang cocok pada kondisi sekarang dan apa paradigma KA yang cocok.</p><p><strong>Jawaban:</strong> Definisi yang cocok: <em>KA adalah sistem/artifak komputer yang mampu mengamati lingkungan, belajar dari data/pengetahuan, membuat keputusan, dan bertindak untuk mencapai tujuan yang bermanfaat bagi manusia.</em> Paradigma yang cocok: <strong>hybrid data-driven + simbolik</strong> — utamakan <em>machine learning</em> (deep learning) untuk persepsi & prediksi, dipadukan dengan komponen simbolik/penalaran (knowledge/rules, probabilistic models) untuk interpretabilitas, pengendalian kebijakan, dan keselamatan.</p><hr><p><strong>2.a Pertanyaan:</strong> Deskripsikan sebuah contoh permainan game yang cocok diselesaikan dengan informed search.</p><p><strong>Jawaban:</strong> Contoh: <em>8-puzzle</em> (geser ubin 3×3 ke posisi tujuan). Informed search efektif karena ada heuristik (misal Manhattan distance) mempercepat pencarian solusi.</p><p><strong>2.b Pertanyaan:</strong> Buatlah state space, dan tuliskan algoritmanya untuk mendapatkan hasil akhir.<br><strong>Jawaban (ringkas):</strong></p><ul><li><p>State space: semua konfigurasi tata letak 9 ubin (termasuk kotak kosong).</p></li><li><p>Operator: geser kotak kosong {up, down, left, right} bila legal.</p></li><li><p>Start: konfigurasi awal; Goal: konfigurasi target.</p></li><li><p>Heuristik: h(n) = jumlah Manhattan distance tiap ubin ke pos tujuan.</p></li><li><p>Algoritma: <strong>A*</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>function</span> <span class=n>A</span><span class=o>*</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>goal</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nb>open</span> <span class=o>:=</span> <span class=p>{</span><span class=n>start</span><span class=p>}</span> <span class=k>with</span> <span class=n>f</span><span class=p>(</span><span class=n>start</span><span class=p>)</span><span class=o>=</span><span class=n>g</span><span class=p>(</span><span class=n>start</span><span class=p>)</span><span class=o>+</span><span class=n>h</span><span class=p>(</span><span class=n>start</span><span class=p>),</span> <span class=n>g</span><span class=p>(</span><span class=n>start</span><span class=p>)</span><span class=o>=</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=n>closed</span> <span class=o>:=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=nb>open</span> <span class=ow>not</span> <span class=n>empty</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>:=</span> <span class=n>node</span> <span class=ow>in</span> <span class=nb>open</span> <span class=k>with</span> <span class=n>smallest</span> <span class=n>f</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=n>goal</span><span class=p>:</span> <span class=k>return</span> <span class=n>reconstruct_path</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>move</span> <span class=n>n</span> <span class=kn>from</span> <span class=nn>open</span> <span class=n>to</span> <span class=n>closed</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>each</span> <span class=n>successor</span> <span class=n>s</span> <span class=n>of</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>tentative_g</span> <span class=o>:=</span> <span class=n>g</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=o>+</span><span class=n>cost</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>closed</span> <span class=ow>and</span> <span class=n>tentative_g</span> <span class=o>&gt;=</span> <span class=n>g</span><span class=p>(</span><span class=n>s</span><span class=p>):</span> <span class=k>continue</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>s</span> <span class=ow>not</span> <span class=ow>in</span> <span class=nb>open</span> <span class=ow>or</span> <span class=n>tentative_g</span> <span class=o>&lt;</span> <span class=n>g</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>:=</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=n>g</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>:=</span> <span class=n>tentative_g</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>:=</span> <span class=n>g</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>+</span><span class=n>h</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>add</span> <span class=n>s</span> <span class=n>to</span> <span class=nb>open</span>
</span></span></code></pre></div></li></ul><hr><p><strong>3.a Pertanyaan:</strong> Buatlah bagan sistem inferensi fuzzy, jelaskan masing-masing bagiannya.</p><p><strong>Jawaban (ringkas):</strong> Bagan komponen:</p><ol><li><strong>Fuzzification</strong> — ubah input numerik ke derajat keanggotaan pada himpunan fuzzy.</li><li><strong>Knowledge / Rule base</strong> — kumpulan aturan IF–THEN (linguistik).</li><li><strong>Inference engine</strong> — evaluasi aturan, kombinasikan antecedent untuk menghasilkan fuzzy output (tingkat aktivasi rule).</li><li><strong>Aggregation</strong> — gabungkan kontribusi semua rule ke fungsi keanggotaan output fuzzy.</li><li><strong>Defuzzification</strong> — konversi output fuzzy ke nilai numerik tunggal (mis. centroid).</li></ol><hr><p><strong>3.b Pertanyaan:</strong> Buatlah sebuah contoh sistem inferensi fuzzy yg menggunakan 3 input, 1 output diluar yg telah dibahas di kelas.</p><p><strong>Jawaban (ringkas):</strong> <em>Sistem irigasi pintar</em></p><ul><li>Input: SoilMoisture (kelembaban tanah), RainProb (probabilitas hujan), PlantNeed (kebutuhan air tanaman).</li><li>Output: IrrigationDuration (durasi penyiraman dalam menit).</li></ul><p><strong>3.c Pertanyaan:</strong> Buatlah himpunan fuzzy untuk masing parameter.</p><p><strong>Jawaban (ringkas):</strong> (semua rentang contoh 0–100 kecuali duration 0–60 menit)</p><ul><li>SoilMoisture: {Low (0–40), Medium (30–70), High (60–100)} (triangular/trapezoid).</li><li>RainProb: {Low (0–30), Medium (20–70), High (60–100)}.</li><li>PlantNeed: {Low (0–30), Normal (20–70), High (60–100)}.</li><li>IrrigationDuration: {Short (0–15), Medium (10–30), Long (25–60)}.</li></ul><p><strong>3.d Pertanyaan:</strong> Buatlah 4 fuzzy rules yang mengandung paling tidak dua konklusi yang menjadi premis di rules yang lain.</p><p><strong>Jawaban (ringkas):</strong> (gunakan variabel antara <em>Urgency</em> sebagai intermediate)</p><ul><li>R1: IF SoilMoisture IS Low THEN Urgency IS High.</li><li>R2: IF RainProb IS High THEN Urgency IS Low.</li><li>R3: IF Urgency IS High AND PlantNeed IS High THEN IrrigationDuration IS Long.</li><li>R4: IF Urgency IS Medium OR RainProb IS Medium THEN IrrigationDuration IS Medium.</li></ul><p>(Keterangan: R1 & R2 menghasilkan <em>Urgency</em> — yang dipakai oleh R3/R4 sebagai premis.)</p><hr><p><strong>4. Pertanyaan:</strong> Jelaskan bagaimana konsep Kecerdasan Artifisial serta berikan 5 contoh dan penjelasannya bidang aplikasi Kecerdasan Artifisial. Jelaskan dan terapkan metode inferensi yang anda ketahui untuk menghasilkan konklusi.</p><p><strong>Jawaban (ringkas):</strong></p><ul><li><p><strong>Konsep AI:</strong> rekayasa sistem yang <em>persepsi → representasi/pengetahuan → penalaran/decision → aksi</em>, sering memakai probabilitas/statistik dan/atau aturan simbolik untuk mencapai tujuan.</p></li><li><p><strong>5 contoh aplikasi & penjelasan singkat:</strong></p><ol><li><strong>Pengenalan gambar (Computer Vision)</strong> — deteksi objek/segmentasi untuk industri, keamanan.</li><li><strong>Sistem rekomendasi</strong> — menyarankan produk/musik dengan collaborative filtering / ML.</li><li><strong>Chatbot / NLP</strong> — pemrosesan bahasa alami untuk layanan pelanggan.</li><li><strong>Kendaraan otonom</strong> — integrasikan sensor + planning + control untuk mengemudi.</li><li><strong>Diagnosis medis berbasis AI</strong> — klasifikasi citra/risk scoring untuk membantu keputusan klinis.</li></ol></li><li><p><strong>Metode inferensi (contoh aplikasi rule-based, forward chaining):</strong><br>Contoh singkat: Sistem bantuan diagnostik (aturan):</p><ul><li>Rule A: IF fever AND cough THEN suspect_infection.</li><li>Rule B: IF suspect_infection AND chest_pain THEN suspect_pneumonia.</li><li>Fact: fever = true, cough = true, chest_pain = true.<br>Forward chaining: dari Rule A → suspek_infection; dari suspek_infection + chest_pain + Rule B → suspek_pneumonia (konklusi).</li></ul></li></ul><hr><p><strong>5. Pertanyaan:</strong> Salah satu teknik penting dalam Kecerdasan Artifisial adalah searching. Sebutkan, jelaskan dan berilah contoh hal-hal yang berkaitan dengan proses searching tersebut! (5%)</p><p><strong>Jawaban (ringkas):</strong></p><ul><li><strong>Komponen dasar</strong>: state space, initial state, goal test, operators, path cost, solusi (path).</li><li><strong>Uninformed search</strong>: tidak pakai heuristik. Contoh: BFS (lengkap, optimal jika cost=1), DFS (hemat memori, tidak optimal), Uniform-cost (optimal untuk biaya).</li><li><strong>Informed search (heuristic)</strong>: pakai fungsi heuristik h(n). Contoh: Greedy best-first (cepat, tidak optimal), A* (optimal jika h admissible).</li><li><strong>Local search / hill-climbing</strong>: optimisasi tanpa eksplorasi penuh (contoh: simulated annealing, genetic algorithms).</li><li><strong>Contoh aplikasi</strong>: pathfinding di game (A*), puzzle solving (8-puzzle dengan A*), optimasi jadwal (genetic algorithms).</li></ul><hr><p><strong>6. Diberikan pernyataan-pernyataan berikut&mldr;</strong><br>Pernyataan:</p><ul><li>Budi suka semua jenis makanan.</li><li>Apel adalah makanan.</li><li>Ayam goreng adalah makanan.</li><li>Sesuatu yang dimakan dan tidak membuat mati adalah makanan.</li><li>Johan makan kacang dan masih hidup.</li><li>Susi makan setiap yang dimakan Johan.</li></ul><p><strong>6.a Pertanyaan:</strong> Tuliskan kalimat-kalimat tersebut dalam logika predikat!<br><strong>Jawaban (ringkas):</strong> (predikat: Food(x), Likes(budi,x), Eats(person,x), AliveAfterEating(person,x))</p><ol><li>∀x (Food(x) → Likes(Budi,x)).</li><li>Food(apel).</li><li>Food(ayam_goreng).</li><li>∀y∀z (Eats(y,z) ∧ AliveAfterEating(y,z) → Food(z)).</li><li>Eats(Johan,kacang) ∧ AliveAfterEating(Johan,kacang).</li><li>∀x (Eats(Johan,x) → Eats(Susi,x)).</li></ol><p><strong>6.b Pertanyaan:</strong> Dengan menggunakan teknik resolusi, tunjukkan bahwa Budi suka kacang!<br><strong>Jawaban (ringkas, langkah resolusi):</strong></p><ul><li>Dari (5) dan (4): Eats(Johan,kacang) ∧ AliveAfterEating(Johan,kacang) ⇒ Food(kacang). (instansiasi)</li><li>Dari (1) dan Food(kacang) ⇒ Likes(Budi,kacang). (modus ponens / resolusi)<br>Jadi: <strong>Likes(Budi,kacang)</strong>. (terbukti)</li></ul><p><strong>6.c Pertanyaan:</strong> Gunakan teknik resolusi untuk menjawab pertanyaan: &ldquo;Apa makanan yang dimakan Susi.&rdquo;<br><strong>Jawaban (ringkas):</strong></p><ul><li>Dari (5): Eats(Johan,kacang). Dari (6): Eats(Johan,kacang) → Eats(Susi,kacang). Jadi <strong>Susi makan kacang</strong>.</li><li>Umum: Susi makan semua yang Johan makan (∀x Eats(Johan,x) → Eats(Susi,x)), jadi Susi makan setiap item yang Johan makan (di sini: kacang).</li></ul><hr><h2 id=flash-card>Flash Card<a hidden class=anchor aria-hidden=true href=#flash-card>#</a></h2><h3 id=kartu-flash--pengenalan-kecerdasan-buatan-110>Kartu Flash — Pengenalan Kecerdasan Buatan (1–10)<a hidden class=anchor aria-hidden=true href=#kartu-flash--pengenalan-kecerdasan-buatan-110>#</a></h3><ol><li><p>Q: Apa definisi singkat Kecerdasan Buatan (AI)?<br>A: Sistem komputer yang mengamati lingkungan, memproses informasi, belajar, dan bertindak untuk mencapai tujuan tertentu.</p></li><li><p>Q: Sebutkan dua pendekatan utama dalam AI.<br>A: Pendekatan simbolik (aturan/logika) dan pendekatan statistik/pembelajaran (ML/DL).</p></li><li><p>Q: Apa yang dimaksud agen rasional?<br>A: Agen yang memilih aksi untuk memaksimalkan expected performance berdasarkan persepsi dan pengetahuan.</p></li><li><p>Q: Mengapa etika penting dalam pengembangan AI?<br>A: Karena AI dapat mempengaruhi keselamatan, privasi, fairness, dan keputusan bernilai pada manusia.</p></li><li><p>Q: Apa perbedaan antara AI kuat (strong AI) dan AI lemah (weak AI)?<br>A: Weak AI fokus tugas spesifik; strong AI berarti kemampuan kognitif umum setara manusia.</p></li><li><p>Q: Sebutkan satu contoh aplikasi AI di kehidupan sehari-hari.<br>A: Rekomendasi produk, asisten virtual, deteksi wajah, atau kendaraan otonom.</p></li><li><p>Q: Mengapa hybrid (simbolik + statistik) sering digunakan?<br>A: Untuk memanfaatkan interpretabilitas aturan sekaligus kekuatan generalisasi data-driven.</p></li><li><p>Q: Apa arti “bias data” pada AI?<br>A: Ketidakseimbangan atau pola buruk di data yang menyebabkan model membuat keputusan tidak adil.</p></li><li><p>Q: Apa tujuan evaluasi model AI?<br>A: Menilai kinerja, generalisasi, keandalan, dan kecocokan model untuk tugas nyata.</p></li><li><p>Q: Sebutkan satu batasan penting AI modern.<br>A: Kebutuhan data banyak; kadang sulit interpretasi (black-box).</p></li></ol><h3 id=kartu-flash--agen-cerdas-1120>Kartu Flash — Agen Cerdas (11–20)<a hidden class=anchor aria-hidden=true href=#kartu-flash--agen-cerdas-1120>#</a></h3><ol start=11><li><p>Q: Apa fungsi agen?<br>A: Mapping dari percept (input sensor) ke aksi (action).</p></li><li><p>Q: Jenis agen sederhana pertama yang sering dibahas?<br>A: Simple reflex agent (respon berdasarkan kondisi sekarang).</p></li><li><p>Q: Kapan simple reflex agent gagal?<br>A: Saat lingkungan partial observable atau memerlukan memori/history.</p></li><li><p>Q: Apa itu model-based agent?<br>A: Agen yang menyimpan state internal/model lingkungan untuk membuat keputusan.</p></li><li><p>Q: Bedakan goal-based dan utility-based agent.<br>A: Goal-based berorientasi mencapai goal; utility-based memaksimalkan nilai utilitas yang mengukur preferensi.</p></li><li><p>Q: Sebutkan dua dimensi karakter lingkungan agen.<br>A: Observable vs partially observable; deterministic vs nondeterministic.</p></li><li><p>Q: Apa arti environment episodic vs sequential?<br>A: Episodic: setiap episode independen; sequential: keputusan sekarang mempengaruhi masa depan.</p></li><li><p>Q: Apa tantangan pada multi-agent environment?<br>A: Koordinasi, kompetisi, komunikasi, dan ketidakpastian perilaku agen lain.</p></li><li><p>Q: Mengapa representasi state penting pada agen?<br>A: Karena menentukan apa yang agen ketahui dan bagaimana dia merencanakan aksi.</p></li><li><p>Q: Contoh nyata utility-based agent.<br>A: Agen trading yang memaksimalkan expected return dengan penalti risiko.</p></li></ol><h3 id=kartu-flash--searching--pencarian-solusi-2130>Kartu Flash — Searching / Pencarian Solusi (21–30)<a hidden class=anchor aria-hidden=true href=#kartu-flash--searching--pencarian-solusi-2130>#</a></h3><ol start=21><li><p>Q: Apa komponen utama formulasi masalah pencarian?<br>A: Initial state, actions, transition model, goal test, cost function.</p></li><li><p>Q: Apa tujuan algoritma search?<br>A: Menemukan urutan aksi dari initial state ke goal state.</p></li><li><p>Q: Kapan BFS lebih cocok daripada DFS?<br>A: Saat solusi paling dangkal dicari dan ruang status terdiskret/sedang.</p></li><li><p>Q: Apa kelebihan dan kekurangan DFS?<br>A: Kelebihan memori rendah; kekurangan bisa tidak lengkap dan terjebak di cabang tak hingga.</p></li><li><p>Q: Apa itu Uniform Cost Search (UCS)?<br>A: Search yang memilih node dengan biaya kumulatif terkecil (optimal untuk biaya non-negatif).</p></li><li><p>Q: Rumus utama A* dan maknanya.<br>A: f(n)=g(n)+h(n). g biaya dari start ke n; h estimasi biaya n→goal.</p></li><li><p>Q: Apa itu heuristik admissible?<br>A: Heuristik yang tidak pernah melebih-lebihkan biaya sebenarnya ke goal (underestimate).</p></li><li><p>Q: Mengapa konsistensi heuristik penting?<br>A: Konsisten (monotonic) memastikan f tidak menurun dan membuat A* lebih efisien (tidak perlu reopen node).</p></li><li><p>Q: Bagaimana membuat heuristik dari relaksasi masalah?<br>A: Hilangkan beberapa constraint sehingga solusi relaksasi mudah dihitung → gunakan biaya relaksasi sebagai h.</p></li><li><p>Q: Apa trade-off antara beam search dan A*?<br>A: Beam lebih hemat memori tapi tidak lengkap/optimal; A* lengkap/optimal dengan heuristik admissible tapi memori besar.</p></li></ol><h3 id=kartu-flash--knowledge-representation-3140>Kartu Flash — Knowledge Representation (31–40)<a hidden class=anchor aria-hidden=true href=#kartu-flash--knowledge-representation-3140>#</a></h3><ol start=31><li><p>Q: Apa tujuan Knowledge Representation (KR)?<br>A: Menyimpan pengetahuan sehingga mesin dapat melakukan inferensi dan membuat keputusan.</p></li><li><p>Q: Bedakan propositional vs predicate logic.<br>A: Propositional: atom tanpa argumen; predicate: fungsi/predikat dengan variabel → ekspresivitas lebih tinggi.</p></li><li><p>Q: Apa itu ontology dalam KR?<br>A: Model konsep dan relasi domain untuk komunikasi dan interoperabilitas pengetahuan.</p></li><li><p>Q: Fungsi semantic network?<br>A: Merepresentasikan konsep sebagai node dan relasi sebagai edge untuk inferensi berbasis jaringan.</p></li><li><p>Q: Apa itu nonmonotonic reasoning?<br>A: Penalaran di mana menambah informasi baru dapat mengubah kesimpulan sebelumnya (default assumptions).</p></li><li><p>Q: Untuk apa truth maintenance system (TMS)?<br>A: Melacak justifikasi untuk fakta sehingga dapat retract (membatalkan) dengan konsisten.</p></li><li><p>Q: Kapan description logic biasa dipakai?<br>A: Untuk ontologies dan reasoning tentang kelas, subclass, dan keterbatasan (mis. OWL).</p></li><li><p>Q: Apa role event calculus?<br>A: Merepresentasikan events, waktu, dan efeknya pada status world untuk reasoning temporal.</p></li><li><p>Q: Apa tantangan utama saat membangun knowledge base dari teks?<br>A: Ambiguitas bahasa, inkonsistensi, pengenalan entitas, dan skala data.</p></li><li><p>Q: Sebutkan satu metode untuk menangani default assumptions.<br>A: Default logic atau circumscription untuk mengekspresikan asumsi “kecuali terbukti sebaliknya”.</p></li></ol><h3 id=kartu-flash--nlp-pengolahan-bahasa-alami-4150>Kartu Flash — NLP (Pengolahan Bahasa Alami) (41–50)<a hidden class=anchor aria-hidden=true href=#kartu-flash--nlp-pengolahan-bahasa-alami-4150>#</a></h3><ol start=41><li><p>Q: Apa itu model n-gram?<br>A: Model probabilistik yang memprediksi kata berikutnya berdasarkan (n−1) kata sebelumnya.</p></li><li><p>Q: Kenapa smoothing diperlukan pada n-gram?<br>A: Untuk memberi probabilitas pada n-gram yang tidak muncul di data training (menghindari nol).</p></li><li><p>Q: Sebutkan satu teknik smoothing.<br>A: Laplace smoothing (add-one) atau Kneser-Ney.</p></li><li><p>Q: Apa itu PCFG?<br>A: Probabilistic Context-Free Grammar — grammar kontekstual dengan probabilitas untuk produksi aturan.</p></li><li><p>Q: Untuk apa algoritma CYK dipakai? dan kompleksitasnya?<br>A: Parsing dengan grammar CNF; kompleksitas O(n³) (n = panjang kalimat).</p></li><li><p>Q: Perbedaan parsing dependensi dan parsing konstituen?<br>A: Dependensi fokus relasi antar kata; konstituen fokus struktur frasa dan pohon konstituen.</p></li><li><p>Q: Apa itu word embedding?<br>A: Representasi vektor kata yang menangkap makna/kemiripan semantik (mis. word2vec).</p></li><li><p>Q: Bagaimana embeddings membantu task NLP?<br>A: Menyediakan fitur kontinu yang menangkap hubungan semantik sehingga model ML lebih efektif.</p></li><li><p>Q: Sebutkan satu aplikasi sederhana model n-gram.<br>A: Language identification, spelling correction, atau predictive text sederhana.</p></li><li><p>Q: Mengapa treebanks penting untuk NLP?<br>A: Sebagai data beranotasi untuk melatih parser, POS tagger, dan model sintaksis lainnya.</p></li></ol><hr></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wewnumam.github.io/id/articles/notes-mrka/><span class=title>« Sebelumnya</span><br><span>Notes MRKA</span>
</a><a class=next href=https://wewnumam.github.io/id/articles/ai-agents-explained/><span class=title>Selanjutnya »</span><br><span>Penjelasan Agen AI – Bagaimana Otonomi, Kolaborasi, dan Pengembangan Diri Mendorong Sistem Cerdas</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on x" href="https://x.com/intent/tweet/?text=Notes%20PKA&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f&amp;title=Notes%20PKA&amp;summary=Notes%20PKA&amp;source=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f&title=Notes%20PKA"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on whatsapp" href="https://api.whatsapp.com/send?text=Notes%20PKA%20-%20https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on telegram" href="https://telegram.me/share/url?text=Notes%20PKA&amp;url=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Notes PKA on ycombinator" href="https://news.ycombinator.com/submitlink?t=Notes%20PKA&u=https%3a%2f%2fwewnumam.github.io%2fid%2farticles%2fnotes-pka%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wewnumam.github.io/id/>Ahmad Adillaumam</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="salin";function s(){t.innerHTML="disalin!",setTimeout(()=>{t.innerHTML="salin"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>